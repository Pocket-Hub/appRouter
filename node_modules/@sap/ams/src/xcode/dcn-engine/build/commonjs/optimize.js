"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _and = _interopRequireDefault(require("./core/condition/and.js"));
var _between = _interopRequireDefault(require("./core/condition/between.js"));
var _equal = _interopRequireDefault(require("./core/condition/equal.js"));
var _false = _interopRequireDefault(require("./core/condition/false.js"));
var _greaterequal = _interopRequireDefault(require("./core/condition/greaterequal.js"));
var _greaterthan = _interopRequireDefault(require("./core/condition/greaterthan.js"));
var _in = _interopRequireDefault(require("./core/condition/in.js"));
var _lessthan = _interopRequireDefault(require("./core/condition/lessthan.js"));
var _like = _interopRequireDefault(require("./core/condition/like.js"));
var _not = _interopRequireDefault(require("./core/condition/not.js"));
var _or = _interopRequireDefault(require("./core/condition/or.js"));
var _true = _interopRequireDefault(require("./core/condition/true.js"));
var _value = _interopRequireDefault(require("./core/condition/value.js"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
/**
 * @typedef {import('./core/condition/condition.js').default} Condition
 */

const Optimizer = {
  /**
   * 
   * @param {Condition} condition 
   * @returns {Condition}
   */
  optimize(condition, force = false) {
    if (condition instanceof _not.default) {
      return new _not.default(this.optimize(condition.condition));
    }
    if (condition instanceof _or.default) {
      let optimized = [];
      for (const cond of condition.conditions) {
        const c2 = this.optimize(cond);
        if (c2.isTrue()) {
          return c2;
        }
        if (c2.isFalse()) {
          continue;
        }
        let keep = true;
        for (let index = 0; index < optimized.length; index++) {
          const c1 = optimized[index];
          if (this.implies(new _not.default(c1), c2)) {
            // this means if opt false => c true => Or true
            // or opt is true => Or true 
            return new _true.default();
          }
          if (this.implies(c2, c1)) {
            // c already covered by opt
            keep = false;
            // continue 
            break;
          }
          if (this.implies(c1, c2)) {
            // we want to keep c instead of opt
            optimized.splice(index, 1);
            index--;
          }
        }
        if (keep) {
          optimized.push(c2);
        }
      }
      return _or.default.create(optimized);
    }
    if (condition instanceof _and.default) {
      let optimized = [];
      for (const cond of condition.conditions) {
        const c2 = this.optimize(cond);
        if (c2.isFalse()) {
          return c2;
        }
        if (c2.isTrue()) {
          continue;
        }
        let keep = true;
        for (let index = 0; index < optimized.length; index++) {
          const c1 = optimized[index];
          if (this.implies(c1, new _not.default(c2))) {
            // this means if c1 true => c2 false => And always false
            return new _false.default();
          }
          if (this.implies(c1, c2)) {
            // c already covered by opt
            keep = false;
            // continue 
            break;
          }
          if (this.implies(c2, c1)) {
            // we want to keep c instead of opt
            optimized.splice(index, 1);
            index--;
          }
        }
        if (keep) {
          optimized.push(c2);
        }
      }
      return _and.default.create(optimized);
    }
    return condition;
  },
  /**
   * 
   * @param {Condition} condition 
   * @param {Condition} impliedCondition 
  	 * @returns {boolean}
   */
  implies(condition, impliedCondition) {
    const commonVars = condition.variables.filter(v => impliedCondition.variables.includes(v));
    if (commonVars.length === 0) {
      return false;
    }
    if (condition instanceof _not.default) {
      return this.contradicts(impliedCondition, condition.condition);
    }
    if (impliedCondition instanceof _not.default) {
      return this.contradicts(condition, impliedCondition.condition);
    }
    if (condition instanceof _or.default) {
      for (const c of condition.conditions) {
        if (!this.implies(c, impliedCondition)) {
          return false;
        }
      }
      return true;
    }
    if (condition instanceof _and.default) {
      for (const c of condition.conditions) {
        if (this.implies(c, impliedCondition)) {
          return true;
        }
      }
      return false;
    }
    if (impliedCondition instanceof _or.default) {
      for (const c of impliedCondition.conditions) {
        if (this.implies(condition, c)) {
          return true;
        }
      }
      return false;
    }
    if (impliedCondition instanceof _and.default) {
      for (const c of impliedCondition.conditions) {
        if (!this.implies(condition, c)) {
          return false;
        }
      }
      return true;
    }
    if (condition instanceof _in.default) {
      const array = condition.values[1].constant;
      if (!Array.isArray(array)) {
        return false;
      }
      return this.implies(_or.default.create(array.map(v => new _equal.default(condition.values[0], _value.default.fromDcn(v)))), impliedCondition);
    }
    if (impliedCondition instanceof _in.default) {
      const array = impliedCondition.values[1].constant;
      if (!Array.isArray(array)) {
        return false;
      }
      return this.implies(condition, _or.default.create(array.map(v => new _equal.default(condition.values[0], _value.default.fromDcn(v)))));
    }
    if (condition instanceof _equal.default) {
      return equalImplies(condition, impliedCondition, commonVars);
    }
    if (condition instanceof _lessthan.default) {
      return lessThanImplies(condition, impliedCondition, commonVars);
    }
    if (condition instanceof _like.default) {
      return false;
    }
    throw new Error(`unexpected condition type`);
  },
  /**
   * 
   * @param {Condition} condition 
   * @param {Condition} contradictedCondition 
   * @returns {boolean}
   */
  contradicts(condition, contradictedCondition) {
    const commonVars = condition.variables.filter(v => contradictedCondition.variables.includes(v));
    if (commonVars.length === 0) {
      return false;
    }
    if (condition instanceof _not.default) {
      return this.implies(contradictedCondition, condition.condition);
    }
    if (contradictedCondition instanceof _not.default) {
      return this.implies(condition, contradictedCondition.condition);
    }
    if (condition instanceof _or.default) {
      for (const c of condition.conditions) {
        if (!this.contradicts(c, contradictedCondition)) {
          return false;
        }
      }
      return true;
    }
    if (condition instanceof _and.default) {
      for (const c of condition.conditions) {
        if (this.contradicts(c, contradictedCondition)) {
          return true;
        }
      }
      return false;
    }
    if (contradictedCondition instanceof _or.default) {
      for (const c of contradictedCondition.conditions) {
        if (!this.contradicts(condition, c)) {
          return false;
        }
      }
      return true;
    }
    if (contradictedCondition instanceof _and.default) {
      for (const c of contradictedCondition.conditions) {
        if (this.contradicts(condition, c)) {
          return true;
        }
      }
      return false;
    }
    if (condition instanceof _in.default) {
      const array = condition.values[1].constant;
      if (!Array.isArray(array)) {
        return false;
      }
      return this.contradicts(_or.default.create(array.map(v => new _equal.default(condition.values[0], _value.default.fromDcn(v)))), contradictedCondition);
    }
    if (contradictedCondition instanceof _in.default) {
      const array = contradictedCondition.values[1].constant;
      if (!Array.isArray(array)) {
        return false;
      }
      return this.contradicts(condition, _or.default.create(array.map(v => new _equal.default(condition.values[0], _value.default.fromDcn(v)))));
    }
    if (condition instanceof _equal.default) {
      return equalContradicts(condition, contradictedCondition, commonVars);
    }
    if (condition instanceof _lessthan.default) {
      return lessThanContradicts(condition, contradictedCondition, commonVars);
    }
    if (condition instanceof _like.default) {
      // only case so far: a like <constant_pattern> implies !a = <string_constant> => ! <string_constant> like <constant_pattern>
      // in order words if the constant in equals does not match the pattern, it is contradicted
      // not worth a own function 
      if (contradictedCondition instanceof _equal.default) {
        const value = contradictedCondition.values.find(v => v.constant).constant;
        if (!value) {
          // both vars a ref but only one common ref => conditions are not related
          return false;
        }
        let input = {};
        input[commonVars[0]] = value;
        return condition.evaluate(input).isFalse();
      }
      return false;
    }
    throw new Error(`unexpected condition type`);
  },
  /**
   * 
   * @param {Condition} condition 
   * @returns {Condition}
   */
  standardizeOperator(condition) {
    if (condition instanceof _between.default) {
      return new _not.default(new _or.default(new _lessthan.default(condition.values[0], condition.values[1]), new _lessthan.default(condition.values[2], condition.values[0])));
    }
    if (condition instanceof _greaterequal.default) {
      return new _not.default(new _lessthan.default(condition.values[0], condition.values[1]));
    }
    if (condition instanceof _greaterthan.default) {
      return new _lessthan.default(condition.values[1], condition.values[0]);
    }
    return condition;
  }
};
/**
 * 
 * @param {Equal} equalCondition 
 * @param {Condition} impliedCondition 
 * @param {String[]} commonVars
 * @returns {boolean}
 */
function equalImplies(equalCondition, impliedCondition, commonVars) {
  if (commonVars.length === 2) {
    if (impliedCondition instanceof _equal.default) {
      return true;
    }
    if (impliedCondition instanceof _like.default) {
      // a=b => a like b
      return equalCondition.variables.includes(impliedCondition.values[0].reference) && equalCondition.variables.includes(impliedCondition.values[1].reference);
    }
    return false;
  }
  const value = equalCondition.values.find(v => v.constant)?.constant;
  if (!value) {
    // both vars a ref but only one common ref => conditions are not related
    return false;
  }
  let input = {};
  input[commonVars[0]] = value;
  return impliedCondition.evaluate(input).isTrue();
}

/**
 * 
 * @param {Equal} equalCondition 
 * @param {Condition} contradicted 
 * @param {String[]} commonVars
 * @returns {boolean}
 */
function equalContradicts(equalCondition, contradicted, commonVars) {
  if (commonVars.length === 2) {
    if (contradicted instanceof _lessthan.default) {
      //a=b => !a<b
      return true;
    }
    return false;
  }
  const value = equalCondition.values.find(v => v.constant)?.constant;
  if (!value) {
    // both vars a ref but only one common ref => conditions are not related
    return false;
  }
  let input = {};
  input[commonVars[0]] = value;
  return contradicted.evaluate(input).isFalse();
}

/**
 * 
 * @param {LessThan} lessThan 
 * @param {Condition} impliedCondition 
 * @param {String[]} commonVars
 * @returns {boolean}
 */
function lessThanImplies(lessThan, impliedCondition, commonVars) {
  if (commonVars.length === 2) {
    if (impliedCondition instanceof _lessthan.default) {
      return lessThan.values[0].reference === impliedCondition.values[0].reference;
    }
    return false;
  }
  const varIndex = lessThan.values.findIndex(v => v.reference === commonVars[0]);
  const value = lessThan.values[(varIndex + 1) % 2].constant;
  if (!value) {
    // both vars a ref but only one common ref => conditions are not related
    return false;
  }
  const impliedVarIndex = impliedCondition.values.findIndex(v => v.reference === commonVars[0]);
  const impliedValue = impliedCondition.values[(impliedVarIndex + 1) % 2].constant;
  if (!impliedValue) {
    // both vars a ref but only one common ref => conditions are not related
    return false;
  }
  if (impliedCondition instanceof _lessthan.default) {
    if (impliedVarIndex !== varIndex) {
      // can't imply anything from lt => gt
      return false;
    }
    if (varIndex === 0) {
      // a<3 => a<4
      return value <= impliedValue;
    }
    if (varIndex === 1) {
      // 3<a => 2<a
      return value >= impliedValue;
    }
  }
  return false;
}
/**
 * 
 * @param {LessThan} lessThan 
 * @param {Condition} contradictedCondition 
 * @param {String[]} commonVars
 * @returns {boolean}
 */
function lessThanContradicts(lessThan, contradictedCondition, commonVars) {
  if (commonVars.length === 2) {
    if (contradictedCondition instanceof _equal.default) {
      // a<b => !a=b
      return true;
    }
    if (contradictedCondition instanceof _lessthan.default) {
      // a<b => !b<a
      return lessThan.values[0].reference !== contradictedCondition.values[0].referenc;
    }
    return false;
  }
  const varIndex = lessThan.values.findIndex(v => v.reference === commonVars[0]);
  const value = lessThan.values[(varIndex + 1) % 2].constant;
  if (!value) {
    // todo deduct further implications on non-common variable
    // both vars a ref but only one common ref => conditions are not related
    return false;
  }
  const impliedVarIndex = contradictedCondition.values.findIndex(v => v.reference === commonVars[0]);
  const impliedValue = contradictedCondition.values[(impliedVarIndex + 1) % 2].constant;
  if (!impliedValue) {
    // todo deduct further implications on non-common variable
    // both vars a ref but only one common ref => conditions are not related
    return false;
  }
  if (contradictedCondition instanceof _lessthan.default) {
    if (impliedVarIndex !== varIndex) {
      // a < 1 => ! 1 <= a
      return impliedValue >= value;
    }
    return false;
  }
  if (contradictedCondition instanceof _equal.default) {
    if (varIndex === 0) {
      // a < 1 => ! a = 1
      // a < 1 => ! a = 2
      return impliedValue >= value;
    }
    // 1 < a => ! a = 1
    // 1 < a => ! a = 0
    return value >= impliedValue;
  }
  return false;
}
var _default = exports.default = Optimizer;
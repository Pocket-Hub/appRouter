"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _and = _interopRequireDefault(require("./condition/and.js"));
var _comparisonoperator = _interopRequireDefault(require("./condition/comparisonoperator.js"));
var _false = _interopRequireDefault(require("./condition/false.js"));
var _not = _interopRequireDefault(require("./condition/not.js"));
var _or = _interopRequireDefault(require("./condition/or.js"));
var _true = _interopRequireDefault(require("./condition/true.js"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
/**
 * @typedef {import('./core/condition/condition.js').default} Condition
 */

const UnsetIgnoreProcessor = {
  /**
   * Implementaion of UNSET/IGNORE Logic
   *   not(UNSET) = UNSET
   *   not(IGNORE) = IGNORE 
   *   
   *   a=1 OR IGNORE => IGNORE but:
   *   NOT(a=1 OR IGNORE) => NOT(a=1) because should be equivalent to
   *   NOT(a=1) AND NOT(IGNORE) => NOT(a=1) AND IGNORE => NOT(a=1)   
   * 
   * therefor we need the invertedLogic parameter to change behavior inside not
   * full describion here:
   * https://github.wdf.sap.corp/CPSecurity/cas-ams-dcn/blob/main/doc/enhanced-bool.MD
   * @param {boolean} [invertedLogic=false] this parameter is used to propagete NOT inside. from outside it must be set to false.
   * @returns {Condition}
   */
  evaluate(unresolvedCondition, unkown, ignore, invertedLogic = false) {
    // we terminate possible is_null, because tehy can result into true false
    let condition = UnsetIgnoreProcessor.terminateUnsetOnIsNull(unresolvedCondition, unkown, ignore);
    if (condition.isTrue() || condition.isFalse()) {
      return condition;
    }

    // from this point on no true/false can occur, so we define True as IGNORE and False as UNSET
    if (condition instanceof _comparisonoperator.default) {
      return UnsetIgnoreProcessor.comparisonOperator(condition, unkown, ignore);
    }
    if (!invertedLogic && condition instanceof _or.default || invertedLogic && condition instanceof _and.default) {
      return UnsetIgnoreProcessor.or(condition, unkown, ignore, invertedLogic);
    }
    if (!invertedLogic && condition instanceof _and.default || invertedLogic && condition instanceof _or.default) {
      return UnsetIgnoreProcessor.and(condition, unkown, ignore, invertedLogic);
    }
    if (condition instanceof _not.default) {
      return UnsetIgnoreProcessor.not(condition, unkown, ignore, invertedLogic); /* node:coverage ignore next 3 */
    }
    throw new Error(`unexpected condition type`);
  },
  /**
   * @param {Condition} condition 
   */
  terminateUnsetOnIsNull(condition, unkown, ignore) {
    const input = {};
    for (const v of condition.variables) {
      if (!unkown.includes(v) && !ignore.includes(v)) {
        input[v] = undefined;
      }
    }
    return condition.evaluate(input);
  },
  or(condition, unkown, ignore, invertedLogic) {
    const conditions = [];
    for (const c of condition.conditions) {
      const evaluated = UnsetIgnoreProcessor.evaluate(c, unkown, ignore, invertedLogic);
      if (evaluated.isTrue()) {
        return evaluated;
      }
      if (!evaluated.isFalse()) {
        conditions.push(evaluated);
      }
    }
    if (conditions.length === 0) {
      return new _false.default();
    }
    if (invertedLogic) {
      // we are actually an And inside a not, therfor we behave like Or, but return an And
      return _and.default.create(conditions);
    }
    return _or.default.create(conditions);
  },
  and(condition, unkown, ignore, invertedLogic) {
    const conditions = [];
    for (const c of condition.conditions) {
      const evaluated = UnsetIgnoreProcessor.evaluate(c, unkown, ignore, invertedLogic);
      if (evaluated.isFalse()) {
        return evaluated;
      }
      if (!evaluated.isTrue()) {
        conditions.push(evaluated);
      }
    }
    if (conditions.length === 0) {
      return new _true.default();
    }
    if (invertedLogic) {
      // we are actually an Or inside a not, therfor we behave like And, but return an Or
      return _or.default.create(conditions);
    }
    return _and.default.create(conditions);
  },
  not(condition, unkown, ignore, invertedLogic) {
    const evaluated = UnsetIgnoreProcessor.evaluate(condition.condition, unkown, ignore, !invertedLogic);
    if (evaluated.isTrue()) {
      return new _true.default();
    }
    if (evaluated.isFalse()) {
      return new _false.default();
    }
    return new _not.default(evaluated);
  },
  comparisonOperator(condition, unkown, ignore) {
    let resolvedToIgnore = false;
    let resolvedToUnset = false;
    for (const v of condition.values) {
      if (v.reference) {
        if (ignore.includes(v.reference)) {
          resolvedToIgnore = true;
        } else if (!unkown.includes(v.reference)) {
          resolvedToUnset = true;
          break;
        }
      }
    }
    if (resolvedToUnset) {
      return new _false.default();
    }
    if (resolvedToIgnore) {
      return new _true.default();
    }
    return condition;
  }
};
var _default = exports.default = UnsetIgnoreProcessor;
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _dcl = require("../util/dcl.js");
var _and = _interopRequireDefault(require("./condition/and.js"));
var _between = _interopRequireDefault(require("./condition/between.js"));
var _equal = _interopRequireDefault(require("./condition/equal.js"));
var _false = _interopRequireDefault(require("./condition/false.js"));
var _function = _interopRequireDefault(require("./condition/function.js"));
var _greaterequal = _interopRequireDefault(require("./condition/greaterequal.js"));
var _greaterthan = _interopRequireDefault(require("./condition/greaterthan.js"));
var _in = _interopRequireDefault(require("./condition/in.js"));
var _is_not_null = _interopRequireDefault(require("./condition/is_not_null.js"));
var _is_null = _interopRequireDefault(require("./condition/is_null.js"));
var _lessequal = _interopRequireDefault(require("./condition/lessequal.js"));
var _lessthan = _interopRequireDefault(require("./condition/lessthan.js"));
var _like = _interopRequireDefault(require("./condition/like.js"));
var _not = _interopRequireDefault(require("./condition/not.js"));
var _not_between = _interopRequireDefault(require("./condition/not_between.js"));
var _not_equal = _interopRequireDefault(require("./condition/not_equal.js"));
var _not_in = _interopRequireDefault(require("./condition/not_in.js"));
var _not_like = _interopRequireDefault(require("./condition/not_like.js"));
var _not_restricted = _interopRequireDefault(require("./condition/not_restricted.js"));
var _or = _interopRequireDefault(require("./condition/or.js"));
var _restricted = _interopRequireDefault(require("./condition/restricted.js"));
var _true = _interopRequireDefault(require("./condition/true.js"));
var _value = _interopRequireDefault(require("./condition/value.js"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
/**
 * @typedef {import('./condition/condition.js').default} Condition
 * @typedef {import('./schema.js').default} Schema
 */
const Dcn = {
  /**
   * @param {Schema} schema 
   * @returns {Condition}
   */
  condition(dcnCondition = {}, schema) {
    if (dcnCondition === true) {
      return new _true.default();
    } else if (dcnCondition === false) {
      return new _false.default();
    } else if (dcnCondition.ref) {
      return _equal.default.fromDcn([dcnCondition, true]);
    }
    if (!Array.isArray(dcnCondition.call) || dcnCondition.call.length === 0) {
      throw new Error(`Unexpected condition: ${JSON.stringify(dcnCondition)}`);
    }
    if (dcnCondition.call.length > 1) {
      const func = schema.getFunction(dcnCondition.call);
      if (!func) {
        throw new Error(`Unexpected call: ${JSON.stringify(dcnCondition)}`);
      }
      return new _equal.default(func, _value.default.fromDcn(true));
    }
    switch (dcnCondition.call[0]) {
      case "or":
        return _or.default.create(dcnCondition.args.map(arg => Dcn.condition(arg, schema)));
      case "and":
        return _and.default.create(dcnCondition.args.map(arg => Dcn.condition(arg, schema)));
      case "not":
        return _not.default.create(Dcn.condition(dcnCondition.args[0], schema));
      case "eq":
        return _equal.default.fromDcn(dcnCondition.args, schema);
      case "ne":
        return _not_equal.default.fromDcn(dcnCondition.args, schema);
      case "is_null":
        return _is_null.default.fromDcn(dcnCondition.args, schema);
      case "is_not_null":
        return _is_not_null.default.fromDcn(dcnCondition.args, schema);
      case "like":
        return _like.default.fromDcn(dcnCondition.args, schema);
      case "not_like":
        return _not_like.default.fromDcn(dcnCondition.args, schema);
      case "in":
        return _in.default.fromDcn(dcnCondition.args, schema);
      case "not_in":
        return _not_in.default.fromDcn(dcnCondition.args, schema);
      case "lt":
        return _lessthan.default.fromDcn(dcnCondition.args, schema);
      case "ge":
        return _greaterequal.default.fromDcn(dcnCondition.args, schema);
      case "gt":
        return _greaterthan.default.fromDcn(dcnCondition.args, schema);
      case "le":
        return _lessequal.default.fromDcn(dcnCondition.args, schema);
      case "between":
        return _between.default.fromDcn(dcnCondition.args, schema);
      case "not_between":
        return _not_between.default.fromDcn(dcnCondition.args, schema);
      case "restricted":
        return _restricted.default.fromDcn(dcnCondition.args, schema);
      case "not_restricted":
        return _not_restricted.default.fromDcn(dcnCondition.args, schema);
      default:
        throw new Error(`Unexpected call value: "${dcnCondition.call[0]}"`);
    }
  },
  /**
  * @param {*} dcnFunction 
  * @returns {Value}
  */
  function(dcnFunction, schema) {
    if (dcnFunction.returnType !== "Boolean") {
      return _value.default.fromDcn(dcnFunction.result, schema);
    }
    return _function.default.fromCondition(Dcn.condition(dcnFunction.result, schema));
  },
  toHumanReadableString(dcn, depth = 0) {
    let indent = "\t";
    for (let i = 0; i < depth; i++) {
      indent = indent + "\t";
    }
    if (dcn.call && dcn.args) {
      const call = Array.isArray(dcn.call) ? (0, _dcl.stringifyReference)(dcn.call) : dcn.call;
      const args = dcn.args.map(arg => Dcn.toHumanReadableString(arg, depth + 1));
      if (call === "or" || call === "and") {
        return `${call}(\n${indent}${args.join("\n" + indent)}\n${indent})`;
      } else {
        return `${call}(${args.join(",")})`;
      }
    } else if (dcn.ref) {
      return `<${(0, _dcl.stringifyReference)(dcn.ref)}>`;
    } else {
      return JSON.stringify(dcn);
    }
  }
};
var _default = exports.default = Dcn;
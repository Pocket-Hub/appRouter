"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseReference = parseReference;
exports.stringifyReference = stringifyReference;
/**
 * Test whether a string is purely alphanumeric
 */

/**
 * Parses and splits a reference string into parts and returns those parts unescaped as array.
 *
 * @param {string} sReferenceString - The string version of the reference
 * @returns {string[]} The reference parts as string array
 */
function parseReference(sReferenceString) {
  if (sReferenceString.length === 0) {
    return [];
  }
  function findNextUnescapedQuote(sStr, iPosition) {
    let bEscaped = false;
    const sSubStr = sStr.substring(iPosition);
    for (let i = 0; i < sSubStr.length; i++) {
      if (sSubStr[i] === '"' && !bEscaped) {
        return i + iPosition;
      }
      bEscaped = sSubStr[i] === "\\" && !bEscaped;
    }
    return -1;
  }
  const aParts = [];
  let iPos = 0;
  let iLoops = 0;
  while (iPos < sReferenceString.length) {
    iLoops++;
    if (iLoops > sReferenceString.length) {
      console.error(`Loop error in util/dcl/parseReference()"`);
      break;
    }
    const sChar = sReferenceString[iPos];
    if (sChar == '"') {
      const iPos2 = findNextUnescapedQuote(sReferenceString, iPos + 1);
      if (iPos2 > -1 && sReferenceString.length == iPos2 + 1) {
        aParts.push(unescape(sReferenceString.substring(iPos, iPos2 + 1)));
        break; // Done
      } else if (iPos2 > -1 && sReferenceString[iPos2 + 1] == ".") {
        aParts.push(unescape(sReferenceString.substring(iPos, iPos2 + 1)));
        iPos = iPos2 + 2;
      } else {
        // After the " there should be either a . or nothing
        console.error(`Invalid Reference: "${sReferenceString}"`);
        break;
      }
    } else {
      const iPos2 = sReferenceString.indexOf(".", iPos + 1);
      if (iPos2 === -1) {
        aParts.push(sReferenceString.substring(iPos));
        break; // Done
      } else {
        aParts.push(sReferenceString.substring(iPos, iPos2));
        iPos = iPos2 + 1;
      }
    }
  }
  return aParts;
}

/**
 * Creates a string from a reference array (name parts in an array) that joins the parts
 * with ".", escapes and quotes them if needed.
 *
 * @param {string[]} aRef - The array of reference parts
 * @returns {string} The joined and escaped reference string
 */
function stringifyReference(aRef) {
  // TODO : IMPORTANT: this must work exactly like the stringify in the compile server
  // done: https://github.wdf.sap.corp/CPSecurity/cas-dcl-ide/blob/master/documentation/DCLRuntime.md#policy-name-encoding
  return aRef.map(escapeDclElement).join(".");
}

/**
 * Escapes the given part of an attribute and escapes it if needed. Escaping means adding
 * quotes if the part contains special characters (like spaces or dots) and adding a "\"
 * before backslashes and quotes.
 *
 * @param {string} sPart - A part of an attribute (like one element of a ref-array)
 * @returns {string} The escaped version of the same string if there is no need for escaping
 */
function escapeDclElement(sPart) {
  if (sPart.includes(".") || sPart.includes('"')) {
    return escape(sPart);
  }
  return sPart;
  // return needEspace.test(sPart) ? sPart : escape(sPart);
}

/**
 * Generic method to escape backslashes and quotes in a string for use in DCL
 *
 * @param {string} vStr - The DCN name seqment
 * @returns {string} The escaped string or the original number/boolean.
 */
function escape(vStr) {
  return '"' + vStr.replaceAll("\\", "\\\\").replaceAll('"', '\\"') + '"';
}

/**
 * Generic method to unescape backslashes and quotes in a quoted string from DCL
 *
 * @param {string} vStr - The escaped and quoted DCL name
 * @returns {string} The unescaped string or the original number/boolean.
 */
function unescape(vStr) {
  return vStr.slice(1, -1).replaceAll("\\\\", "\\").replaceAll('\\"', '"');
}
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _comparisonoperator = _interopRequireDefault(require("./comparisonoperator.js"));
var _false = _interopRequireDefault(require("./false.js"));
var _true = _interopRequireDefault(require("./true.js"));
var _value = _interopRequireDefault(require("./value.js"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
class Like extends _comparisonoperator.default {
  #regExp = null;
  #pattern = null;
  #escape = null;
  #not = false;
  constructor(value, pattern, escape, not = false) {
    super(value);
    this.#pattern = pattern;
    this.#escape = escape;
    this.#not = not;
    this.#regExp = this.#createRegExp(pattern, escape);
  }
  static fromDcn(dcnArguments = [], schema) {
    const result = new Like(_value.default.fromDcn(dcnArguments[0], schema), dcnArguments[1], dcnArguments[2]);
    // console.error(dcnArguments);
    // console.error(result.toDcn());
    return result;
  }
  #createRegExp(pattern, escape) {
    if (escape) {
      //put placeholders for escaped escape characters
      pattern = pattern.replaceAll(escape + escape, "\x1c");
      //put placeholders for escaped % and _
      pattern = pattern.replaceAll(escape + "%", "\x1e").replaceAll(escape + "_", "\x1f");
      //remove remaining escape characters
      pattern = pattern.replaceAll(escape, "");
    }

    // escape regex characters
    pattern = pattern.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    pattern = pattern.replaceAll("%", ".*");
    pattern = pattern.replaceAll("_", ".");
    if (escape) {
      //put back escaped escape characters
      pattern = pattern.replaceAll("\x1c", escape);
      //put back escaped % and _
      pattern = pattern.replaceAll("\x1e", "%").replaceAll("\x1f", "_");
    }
    return new RegExp(`^${pattern}$`, "g");
  }
  evaluate(input = {}) {
    const v1 = this.values[0].resolve(input);
    if (v1.constant === undefined) {
      return this;
    }

    // Resetting lastIndex feels like a hack, but it is documented here: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/lastIndex#avoiding_side_effects
    this.#regExp.lastIndex = 0;
    if (this.#regExp.test(v1.constant)) {
      return this.#not ? new _false.default() : new _true.default();
    } else {
      return this.#not ? new _true.default() : new _false.default();
    }
  }
  toDcn() {
    const args = [this.values[0].toDcn(), this.#pattern];
    if (this.#escape) {
      args.push(this.#escape);
    }
    return {
      call: [this.#not ? "not_like" : "like"],
      args: args
    };
  }
}
exports.default = Like;
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _attributeName = _interopRequireDefault(require("./attributeName.js"));
var _attributeKeys = _interopRequireDefault(require("./attributeKeys.js"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function Attributes(other) {
  let _json = {};
  let _tokenInfo = null;

  // copy constructor
  if (other instanceof Attributes) {
    const stringify = false;
    _json = other.getJSON(stringify);
  }
  function dcl() {
    if (!_json[_attributeKeys.default.DCL_SECTION]) {
      _json[_attributeKeys.default.DCL_SECTION] = {};
    }
    return _json[_attributeKeys.default.DCL_SECTION];
  }
  function app() {
    if (!_json[_attributeKeys.default.APP_SECTION]) {
      _json[_attributeKeys.default.APP_SECTION] = {};
    }
    return _json[_attributeKeys.default.APP_SECTION];
  }
  function env() {
    if (!_json[_attributeKeys.default.ENV_SECTION]) {
      _json[_attributeKeys.default.ENV_SECTION] = {};
    }
    return _json[_attributeKeys.default.ENV_SECTION];
  }
  function unknowns() {
    if (!_json[_attributeKeys.default.UNKNOWNS_SECTION]) {
      _json[_attributeKeys.default.UNKNOWNS_SECTION] = [];
    }
    return _json[_attributeKeys.default.UNKNOWNS_SECTION];
  }
  function ignores() {
    if (!_json[_attributeKeys.default.IGNORES_SECTION]) {
      _json[_attributeKeys.default.IGNORES_SECTION] = [];
    }
    return _json[_attributeKeys.default.IGNORES_SECTION];
  }
  function dollarUser() {
    if (!env()[_attributeKeys.default.ENV_USER]) {
      env()[_attributeKeys.default.ENV_USER] = {};
    }
    return env()[_attributeKeys.default.ENV_USER];
  }

  /**
   * @param {String} action
   */
  this.setAction = function (action) {
    dcl()[_attributeKeys.default.DCL_ACTION] = action;
    return this;
  };

  /**
   * @return {String} empty string if not set
   */
  this.getAction = function () {
    if (!dcl()[_attributeKeys.default.DCL_ACTION]) {
      return "";
    }
    return dcl()[_attributeKeys.default.DCL_ACTION];
  };

  /**
   * @param {String} resource
   */
  this.setResource = function (resource) {
    dcl()[_attributeKeys.default.DCL_RESOURCE] = resource;
    return this;
  };

  /**
   * @return {String} empty string if not set
   */
  this.getResource = function () {
    if (!dcl()[_attributeKeys.default.DCL_RESOURCE]) {
      return "";
    }
    return dcl()[_attributeKeys.default.DCL_RESOURCE];
  };

  /**
   * @param {String} tenant
   */
  this.setTenant = function (tenant) {
    dcl()[_attributeKeys.default.DCL_TENANT] = tenant;
    return this;
  };

  /**
   * @return {String} empty string if not set
   */
  this.getTenant = function () {
    if (!dcl()[_attributeKeys.default.DCL_TENANT]) {
      return "";
    }
    return dcl()[_attributeKeys.default.DCL_TENANT];
  };

  /**
   * Note that if policies was set before it will be removed from
   * attributes JSON, because only one of the entries can be valid.
   * Please use the ias scim_id instead of the user_uuid
   * @param {Array} keys e.g.: ["zone_a","ias_scim_id"]
   */
  this.setPrincipalToPolicies = function (keys) {
    if (!keys) {
      delete dcl()[_attributeKeys.default.DCL_PRINCIPAL_TO_POLICIES];
      return this;
    }
    let items = Array.isArray(keys) ? keys : [keys];
    dcl()[_attributeKeys.default.DCL_PRINCIPAL_TO_POLICIES] = items;
    delete dcl()[_attributeKeys.default.DCL_POLICIES];
    return this;
  };

  /**
   * @return {Array} empty array if not set
   * e.g. ["zone_a","ias_scim_id"]
   */
  this.getPrincipalToPolicies = function () {
    if (!dcl()[_attributeKeys.default.DCL_PRINCIPAL_TO_POLICIES]) {
      return [];
    }
    return dcl()[_attributeKeys.default.DCL_PRINCIPAL_TO_POLICIES];
  };

  /**
   * Sets the policies Array.
   * Note that the policies have to be prefixed with the DCL
   * package(s) e.g. ["ams.readAllSalesOrders"]
   * Also note that if principal2policies was set before it will be removed, because
   * only one of the entries can be valid.
   * @param {Array} key a list of policies
   */
  this.setPolicies = function (keys) {
    if (!keys) {
      delete dcl()[_attributeKeys.default.DCL_POLICIES];
      return this;
    }
    let items = Array.isArray(keys) ? keys : [keys];
    dcl()[_attributeKeys.default.DCL_POLICIES] = items;
    delete dcl()[_attributeKeys.default.DCL_PRINCIPAL_TO_POLICIES];
    return this;
  };

  /**
   * @return {Array} empty array if not set
   */
  this.getPolicies = function () {
    if (!dcl()[_attributeKeys.default.DCL_POLICIES]) {
      return [];
    }
    return dcl()[_attributeKeys.default.DCL_POLICIES];
  };

  /**
   * Sets scope filtering policies.
   * This is for scenarios where an additional filters need to be applied.
   * Logically the result is computed by doing
   * an AND to the list of qualifiedPolicies that are combined with OR.
   * @param {Array} key a list of policies
   */
  this.setScopeFilterPolicies = function (keys) {
    if (!keys) {
      delete dcl()[_attributeKeys.default.DCL_SCOPE_FILTER];
      return this;
    }
    let items = Array.isArray(keys) ? keys : [keys];
    dcl()[_attributeKeys.default.DCL_SCOPE_FILTER] = items;
    return this;
  };

  /**
   * @return {Array} empty array if not set
   */
  this.getScopeFilterPolicies = function () {
    if (!dcl()[_attributeKeys.default.DCL_SCOPE_FILTER]) {
      return [];
    }
    return dcl()[_attributeKeys.default.DCL_SCOPE_FILTER];
  };

  /**
   * @return {Object} returns the $dcl section of attributes
   */
  this.getDcl = function () {
    return dcl();
  };

  /**
   * @param {Object} pairs app key value pairs e.g. {"country": "DE"}
   */
  this.setApp = function (pairs) {
    if (_json && pairs) {
      _json[_attributeKeys.default.APP_SECTION] = pairs;
    }
    return this;
  };

  /**
   * @return {Object} returns the $app section of attributes
   */
  this.getApp = function () {
    return app();
  };

  /**
   * @param {Object} pairs env key value pairs
   * example for setting $user.country = A :
   * setEnv({
   *			"$user": {
   *				"country": "A"
   *			},
   *		})
   */
  this.setEnv = function (pairs) {
    if (_json && pairs) {
      _json[_attributeKeys.default.ENV_SECTION] = pairs;
    }
    return this;
  };
  this.getEnv = function () {
    return env();
  };
  this.setUserUuid = function (uuid) {
    dollarUser()[_attributeKeys.default.ENV_USER_USER_UUID] = uuid;
    return this;
  };
  this.getUserUuid = function () {
    if (!dollarUser()[_attributeKeys.default.ENV_USER_USER_UUID]) {
      return "";
    }
    return dollarUser()[_attributeKeys.default.ENV_USER_USER_UUID];
  };
  this.setEmail = function (email) {
    dollarUser()[_attributeKeys.default.ENV_USER_EMAIL] = email;
    return this;
  };
  this.getEmail = function () {
    if (!dollarUser()[_attributeKeys.default.ENV_USER_EMAIL]) {
      return "";
    }
    return dollarUser()[_attributeKeys.default.ENV_USER_EMAIL];
  };
  this.setGroups = function (groups) {
    if (!groups) {
      return this;
    }
    let items = Array.isArray(groups) ? groups : [groups];
    dollarUser()[_attributeKeys.default.ENV_USER_GROUPS] = items;
    return this;
  };
  this.getGroups = function () {
    if (!dollarUser()[_attributeKeys.default.ENV_USER_GROUPS]) {
      return [];
    }
    return dollarUser()[_attributeKeys.default.ENV_USER_GROUPS];
  };

  /**
   * Internally transforms the param Arrays to AttributeName Object(s)
   * @param {Array of Strings or AttributeNames} unknowns
   * attributeNames e.g. "addUnknowns(["$app","country"])"
   * or multiple attributeNames e.g. "addUnknowns(["$app"], ["$env","$user"])
   * or directly use AttributeNames e.g. "addUnknowns(AttributeName.fromArray(["$app","country"]))"
   * or if possible from constant e.g. "addUnknowns(AttributeName.common.APP, AttributeName.common.ENV)"
   */
  this.addUnknowns = function (...unknownsArr) {
    // from AttributeNames
    if (_attributeName.default.isAttributeName(unknownsArr[0])) {
      _json[_attributeKeys.default.UNKNOWNS_SECTION] = unknowns().concat(unknownsArr);
    } else {
      // from Array
      addUnknownsOrIgnoresFromArray(unknownsArr, _attributeKeys.default.UNKNOWNS_SECTION);
    }
    return this;
  };

  /**
   * Overwrites the unknowns section in attributes
   * Can take multiple unknowns e.g.: [["$app","country"],["$env","$user"]]
   * Internally transforms the params to AttributeName Object(s)
   * Or directly use AttributeNames e.g. "setUnknowns(AttributeName.fromArray(["$app","country"]))"
   * @param {Array of Array of Strings} stringsArrays
   */
  this.setUnknowns = function (unknowns) {
    // from AttributeNames
    if (_attributeName.default.isAttributeName(unknowns) || Array.isArray(unknowns) && _attributeName.default.isAttributeName(unknowns[0])) {
      _json[_attributeKeys.default.UNKNOWNS_SECTION] = Array.isArray(unknowns) ? unknowns : [unknowns];
    } else {
      // from Array
      unknowns = makeArrayTwoDimensional(unknowns);
      setUnknownsOrIgnoresFromArray(unknowns, _attributeKeys.default.UNKNOWNS_SECTION);
    }
    return this;
  };

  /**
   * returns the set AttributeNames as array
   * @return {Array of AttributeName Objects}
   * Note: use getUnknowns.map(attrName => {attrName.toString()}) to get the string representation
   */
  this.getUnknowns = function () {
    return unknowns();
  };

  /**
   * Internally transforms the params to AttributeName Object(s)
   * @param {Arrays of Arrays of Strings} stringsArrays
   * attributeNames e.g. "addIgnores(["$app","country"])"
   * or multiple attributeNames e.g. "addIgnores(["$app"], "["$env","$user"])
   * or directly use AttributeNames e.g. "addIgnores(AttributeName.fromArray(["$app","country"]))"
   * or if possible from constant e.g. "addIgnores(AttributeName.common.APP, AttributeName.common.ENV)"
   */
  this.addIgnores = function (...ignoresArr) {
    // from AttributeNames
    if (_attributeName.default.isAttributeName(ignoresArr[0])) {
      _json[_attributeKeys.default.IGNORES_SECTION] = ignores().concat(ignoresArr);
    } else {
      // from Array
      addUnknownsOrIgnoresFromArray(ignoresArr, _attributeKeys.default.IGNORES_SECTION);
    }
    return this;
  };

  /**
   * Overwrites the ignores section in attributes
   * Can take multiple AttributeNames e.g.: [["$app","country"],["$env","$user"]]
   * Internally transforms the params to AttributeName Object(s)
   * Or directly use AttributeNames e.g. "setIgnores(AttributeName.fromArray(["$app","country"]))"
   * @param {Arrays of Arrays of Strings} stringsArrays
   */
  this.setIgnores = function (ignores) {
    // from AttributeNames
    if (_attributeName.default.isAttributeName(ignores) || Array.isArray(ignores) && _attributeName.default.isAttributeName(ignores[0])) {
      _json[_attributeKeys.default.IGNORES_SECTION] = Array.isArray(ignores) ? ignores : [ignores];
    } else {
      // from Array
      ignores = makeArrayTwoDimensional(ignores);
      setUnknownsOrIgnoresFromArray(ignores, _attributeKeys.default.IGNORES_SECTION);
    }
    return this;
  };

  /**
   * returns the set AttributeNames as array
   * @return {Array of AttributeName Objects}
   * Note: use getIgnores.map(attrName => {attrName.toString()}) to get the string representation
   */
  this.getIgnores = function () {
    return ignores();
  };

  /**
   * Sets all information that can be retrieved from token. this includes
   * principal2policies: ["zone_id","user_id"]
   * tenant: "zone_id"
   * $user: { // Default $user definition. This is injected, if no custom $user definition is present
   *  user_uuid: String,
   *  groups: String[],
   *  email: String
   * }
   * @param {Object} tokenInfo object retrieved by the xsec lib
   */
  this.setTokenInfo = function (tokenInfo) {
    const userUuid = tokenInfo.getUserId();
    const zoneId = tokenInfo.getAppTID();
    const scimId = tokenInfo.getPayload().scim_id; // TODO replace with dedicated function
    const email = tokenInfo.getPayload().email;
    const groups = tokenInfo.getPayload().groups;

    // set $dcl section
    if (zoneId && scimId) this.setPrincipalToPolicies([zoneId, scimId]);else if (zoneId && userUuid) this.setPrincipalToPolicies([zoneId, userUuid]);
    if (zoneId) this.setTenant(zoneId);

    // set $env section
    if (userUuid) this.setUserUuid(userUuid);
    if (email) this.setEmail(email);
    if (groups) this.setGroups(Array.isArray(groups) ? groups : [groups]);

    // add tokenInfo to retrieve clientId in auditlogging
    _tokenInfo = tokenInfo;
    return this;
  };
  this.getTokenInfo = function () {
    return _tokenInfo;
  };

  /**
   * @param {bool} stringify unknowns and ignores are stored as AttributeNames
   * 	if this value is set to true (default), those will get transformed to strings.
   * 	Also empty json values will be deleted
   * @return {object} returns the whole attribute as JSON object
   */
  this.getJSON = function (stringify = true) {
    return cleanUpJson(_json, stringify, this.getUnknowns(), this.getIgnores());
  };

  /**
   * Returns a formatted JSON string representation of the attribute content.
   */
  this.toString = function () {
    return JSON.stringify(this.getJSON(), null, "  ");
  };

  // helper functions for ignores and unknowns
  function addUnknownsOrIgnoresFromArray(inputArray, key) {
    if (!_json[key]) _json[key] = [];
    if (inputArray.length > 0) {
      _json[key] = _json[key].concat(inputArray.map(stringArray => {
        return _attributeName.default.fromArray(stringArray);
      }));
    }
  }
  function setUnknownsOrIgnoresFromArray(inputArray, key) {
    _json[key] = inputArray.map(stringArray => {
      return _attributeName.default.fromArray(stringArray);
    });
  }
}

/**
 * removes every empty entry in json
 */
function cleanUpJson(obj, stringify, thisUnknowns, thisIgnores) {
  const copy = JSON.parse(JSON.stringify(obj));
  // manually copy unknowns and ignores because they are objects and were removed by the line above
  const copyAttrName = attrName => {
    if (stringify) return attrName.toString();
    return new _attributeName.default(attrName);
  };
  if (thisUnknowns) copy.unknowns = thisUnknowns.map(unknown => {
    return copyAttrName(unknown);
  });
  if (thisIgnores) copy.ignores = thisIgnores.map(ignore => {
    return copyAttrName(ignore);
  });
  function isEmpty(obj) {
    for (let n in obj) {
      return false;
    }
    return true;
  }
  // remove empty entries
  for (let n in copy) {
    if (isEmpty(copy[n])) {
      delete copy[n];
    }
  }
  return copy;
}
function makeArrayTwoDimensional(arr) {
  arr = Array.isArray(arr) ? arr : [arr];
  arr = isTwoDimensionArray(arr) ? arr : [arr];
  return arr;
}
function isTwoDimensionArray(arr) {
  return arr.filter(Array.isArray).length > 0;
}
Attributes.Keys = _attributeKeys.default;
var _default = exports.default = Attributes;
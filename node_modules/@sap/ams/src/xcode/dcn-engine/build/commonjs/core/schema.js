"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _dcl = require("../util/dcl.js");
var _dcn = _interopRequireDefault(require("./dcn.js"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
const dclAttributes = {
  "$dcl": {
    attribute: "Structure",
    nested: {
      "action": {
        attribute: "String"
      },
      "resource": {
        attribute: "String"
      },
      "tenant": {
        attribute: "String"
      },
      "policies": {
        attribute: "String[]"
      },
      "scopeFilter": {
        attribute: "String[]"
      }
    }
  }
};
class Schema {
  name = undefined;
  attributes = {};
  tenantPackages = [];
  functions = {};
  static fromDCN(dcnSchemas, dcnFunctions = []) {
    const schema = new Schema();
    for (const dcnSchema of dcnSchemas) {
      schema.name = dcnSchema.schema;
      if (dcnSchema.tenant) {
        schema.tenantPackages.push({
          package: dcnSchema.schema.slice(0, -1),
          tenant: dcnSchema.tenant
        });
      } else {
        // inject dcl attributes definition only to root schema
        if (!dcnSchema.definition.nested) {
          dcnSchema.definition.nested = {};
        }
        Object.assign(dcnSchema.definition.nested, dclAttributes);
      }
      schema._addAttributeTypesFromDCN([], dcnSchema.definition);
    }
    const sortedDcnFunctions = sortFunctionsByUsage(dcnFunctions);
    for (const dcnFunction of sortedDcnFunctions) {
      const stringName = (0, _dcl.stringifyReference)(dcnFunction.function);
      schema.functions[stringName] = _dcn.default.function(dcnFunction, schema);
    }
    return schema;
  }
  getFunction(functionName) {
    return this.functions[(0, _dcl.stringifyReference)(functionName)];
  }
  getTenantOfPolicy(policyName) {
    const tenantPackage = this.tenantPackages.find(tp => {
      for (let index = 0; index < tp.package.length; index++) {
        if (tp.package[index] !== policyName[index]) {
          return false;
        }
      }
      return true;
    });
    return tenantPackage?.tenant;
  }
  expandAndFlattenVariableList(list) {
    const result = [];
    for (const variable of list) {
      const varName = (0, _dcl.stringifyReference)(variable);
      const varDef = this.attributes[varName];
      if (varDef) {
        result.push(...varDef.includedPrimitiveAttributeNames);
      }
    }
    return result;
  }
  validateAndFlattenInput(input) {
    const result = {};
    for (const key in input) {
      Object.assign(result, this._validateAndFlatten([key], input[key]));
    }
    return result;
  }
  _validateAndFlatten(currentPath, currentValue) {
    let result = {};
    const type = typeof currentValue;
    const stringName = (0, _dcl.stringifyReference)(currentPath);
    const def = this.attributes[stringName];
    if (!def) {
      return {};
    }
    if (def.type === "Structure") {
      if (type === "object") {
        for (const key in currentValue) {
          Object.assign(result, this._validateAndFlatten([...currentPath, key], currentValue[key]));
        }
        return result;
      } else {
        // throw new Error(`input ${stringName} expected to be a structure but is ${type}`);
        return result;
      }
    } else if (def.type.endsWith("[]")) {
      if (!Array.isArray(currentValue)) {
        // throw new Error(`input ${stringName} expected to be ${def.type}`);
        return result;
      }
      if (currentValue.length === 0) {
        result[stringName] = [];
        return result;
      }
      const elementType = typeof currentValue[0];
      if (def.type.slice(0, -2).toLowerCase() !== elementType) {
        // throw new Error(`expected input ${stringName} to be type ${def.type} but is ${elementType}[]`);
        return result;
      }
      for (let i = 1; i < currentValue.length; i++) {
        if (typeof currentValue[i] !== elementType) {
          // throw new Error(`mixed type array ${stringName} is not allowed`);
          return result;
        }
      }
      result[stringName] = currentValue;
      return result;
    } else {
      if (def.type.toLowerCase() !== type && currentValue !== null) {
        // throw new Error(`expected input ${stringName} to be type ${def.type} but is ${type}`);
        return result;
      }
      result[stringName] = currentValue;
      return result;
    }
  }
  _addAttributeTypesFromDCN(currentPath, dcnAttribute) {
    const stringName = (0, _dcl.stringifyReference)(currentPath);
    if (dcnAttribute.attribute === "Structure") {
      const includedPrimitives = [];
      for (const key in dcnAttribute.nested) {
        includedPrimitives.push(...this._addAttributeTypesFromDCN([...currentPath, key], dcnAttribute.nested[key]));
      }
      this.attributes[stringName] = {
        type: dcnAttribute.attribute,
        includedPrimitiveAttributeNames: includedPrimitives
      };
      return includedPrimitives;
    } else {
      this.attributes[stringName] = {
        type: dcnAttribute.attribute,
        includedPrimitiveAttributeNames: [stringName]
      };
      return [stringName];
    }
  }
}
exports.default = Schema;
function sortFunctionsByUsage(dcnFunctions) {
  const dcnFunctionMap = dcnFunctions.reduce((acc, dcnFunc) => {
    acc[(0, _dcl.stringifyReference)(dcnFunc.function)] = dcnFunc;
    return acc;
  }, {});
  const result = [];
  function findUsedFunctions(dcn) {
    if (Array.isArray(dcn.call)) {
      if (dcn.call.length > 1) {
        return [(0, _dcl.stringifyReference)(dcn.call)];
      }
      if (Array.isArray(dcn.args)) {
        const result = [];
        for (const arg of dcn.args) {
          result.push(...findUsedFunctions(arg));
        }
        return result;
      }
    }
    return [];
  }
  function insertFunction(dcnFunction) {
    if (!result.find(f => (0, _dcl.stringifyReference)(f.function) === (0, _dcl.stringifyReference)(dcnFunction.function))) {
      result.push(dcnFunction);
    }
  }
  function insertUsedFunctions(dcnFunctionName, visited = []) {
    if (visited.includes(dcnFunctionName)) {
      throw new Error("Circular function calls are not allowed");
    }
    const dcnFunction = dcnFunctionMap[dcnFunctionName];
    if (!dcnFunction) {
      throw new Error(`unkown function ${dcnFunctionName}`);
    }
    const usedNames = findUsedFunctions(dcnFunction.result);
    const v = [dcnFunctionName, ...visited];
    for (const u of usedNames) {
      insertUsedFunctions(u, v);
      insertFunction(dcnFunctionMap[u]);
    }
  }
  for (const funcName in dcnFunctionMap) {
    insertUsedFunctions(funcName);
    insertFunction(dcnFunctionMap[funcName]);
  }
  return result;
}
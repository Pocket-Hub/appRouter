"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _attributeKeys = _interopRequireDefault(require("./attributeKeys.js"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
/*
* Basically just an array of strings
* But we can not use point separated strings instead because every character is
* allowed even '.' -> points can not be use as separator
*/
function AttributeName(other) {
  this._isAttributeName = true;
  this.segments = [];

  // copy constructor
  if (AttributeName.isAttributeName(other)) {
    this.segments = other.getSegments().slice(); // slice to create copy
  }
}

/**
 * Creates a new AttributeName object from the provided array
 * @param {Array} array 
 * @returns new AttributeNames with array items as segments
 */
AttributeName.fromArray = function (array) {
  const segments = Array.isArray(array) ? array : [array];
  return new AttributeName().set(segments);
};

/**
 * Creates a new AttributeName object from the provided string
 * @param {String} str 
 * @returns new AttributeNames with segments extracted from the string
 */
AttributeName.fromString = function (str) {
  return AttributeName.fromArray(stringToSegments(str));
};
AttributeName.prototype.getFirstSegment = function () {
  return this.segments[0];
};
AttributeName.prototype.getSegments = function () {
  return this.segments;
};

/**
 * @param {int} index starting with zero
 * @returns string content of segment
 */
AttributeName.prototype.getSegment = function (index) {
  return this.segments[index];
};
AttributeName.prototype.size = function () {
  return this.segments.length;
};
AttributeName.prototype.isEmpty = function () {
  return this.segments.length == 0;
};

// adds one segment to the AttributeName
AttributeName.prototype.add = function (segment) {
  this.segments.push(segment);
  return this;
};

// sets all segments of the AttributeName
AttributeName.prototype.set = function (segments) {
  this.segments = segments;
  return this;
};

/**
 * @return {String} returns a String representation separated by dots
 */
AttributeName.prototype.toString = function () {
  // quote segments containing '.'
  const tmpSegments = this.segments.map(segment => {
    if (segment.includes(".")) segment = `"${segment}"`;
    return segment;
  });
  return tmpSegments.join(".");
};

/**
 * @return {String} returns an encoded String representation
 */
AttributeName.prototype.toOpaInputName = function () {
  return AttributeName.toOpaInputName(this);
};

/**
 * To verify if an object is of type AttributeName
 */
AttributeName.isAttributeName = function (obj) {
  return obj && (obj instanceof AttributeName || Boolean(obj._isAttributeName));
};

// Algorithm copied from AMS Java Lib:
// https://github.wdf.sap.corp/CPSecurity/cas-dcl-ide/blob/master/rt.parent/rt.opa/src/main/java/com/sap/cloud/security/ams/dcl/rt/opa/OpaTools.java#L76-L109
/**
 * Takes as argument an AttributeName and creates a opaInputString
 * This function is used internally in the policyDecisionPoint
 * @param {String} attrName is the attributeName in string form eg. ($dcl.resource)
 * @return {String} returns an encoded String representation eg. "input[\"$dcl\"][\resource\"]",
 * this is necessary for the post request to the opa
 */
AttributeName.toOpaInputName = function (attrName) {
  const INPUT_KEY = "input";
  let opaInputName = "";
  if (!attrName) {
    throw new Error("AttributeName parameter must be defined");
  }
  if (!AttributeName.isAttributeName(attrName)) {
    throw new Error("Input parameter must be of type AttributeName");
  }
  if (attrName.isEmpty()) {
    return INPUT_KEY;
  }
  opaInputName += INPUT_KEY;
  for (let j = 0; j < attrName.size(); ++j) {
    const id = attrName.getSegment(j);
    opaInputName += "[\"";
    if (id.includes("\\") || id.includes("\"")) {
      for (let i = 0; i < id.length; ++i) {
        const ch = id.charAt(i);
        if (ch == "\\") {
          opaInputName += "\\\\";
        } else if (ch == "\"") {
          opaInputName += "\\\"";
        } else {
          opaInputName += ch;
        }
      }
    } else {
      opaInputName += id;
    }
    opaInputName += "\"]";
  }
  return opaInputName;
};

/**
 * transforms string to AttributeName segments
 * "author.created" -> ["author", "created"]
 * @param {String} str 
 */
function stringToSegments(str) {
  // pre checks
  // empty segments like '..' pr '""' are not allowed
  const emptySegmentRegex = /\.\.|""/g;
  if (str.match(emptySegmentRegex)) throw "no empty segments allowed";
  // 'bla."abc"abc' second abc should not be matched
  // 'abc"abc"' first abc should not be matched
  // false input if before and after a single double quote are characters not of type '.' or '\'
  const quoteError = /[^\.\\]"[^\.\\]/g;
  if (str.match(quoteError)) throw "segments must start with '.' or '\"'";

  /**
   * "(?:\\.|[^"\\])*"   # capture inside of double quotes but allow \ and \" inside
   * |                   # orâ€¦
   * [^\.]+              # everything that is not dot -> unlimited times
   */
  const splitSegmentsRegex = /"(?:\\.|[^"\\])*"|[^\.]+/g;
  let segments = str.match(splitSegmentsRegex);
  if (!segments) throw "no segment found in input string";

  // post checks
  segments = segments.map(segment => {
    // quoted segment
    if (segment.charAt(0) === '"' && segment.charAt(segment.length - 1) === '"') {
      // quotes defining fragments are not removed by splitSegmentsRegex -> delete beginning and ending quotes
      segment = segment.slice(1, -1);
    } else {
      // not quoted segment
      // 'abc."abc' should not be allowed because " is not inside of double quote
      const hasSingleQuoteRegex = /^(?!\\)"|[^\\]".?/g;
      if (segment.match(hasSingleQuoteRegex)) throw "string not terminated by \"";
    }
    // remove escape character before quotes in quoted segments
    segment = segment.replace(/\\"/g, '"');
    return segment;
  });
  const firstSegment = segments[0];
  const topLevelSegments = [_attributeKeys.default.DCL_SECTION, _attributeKeys.default.APP_SECTION, _attributeKeys.default.ENV_SECTION];
  // automatically adjust first segment for $app or $user if it's not $dcl, $app or $env
  if (topLevelSegments.indexOf(firstSegment) === -1) {
    if (firstSegment.startsWith("$")) {
      segments = [_attributeKeys.default.ENV_SECTION, ...segments];
    } else {
      segments = [_attributeKeys.default.APP_SECTION, ...segments];
    }
  }
  return segments;
}
AttributeName.common = {
  // APP section
  APP: AttributeName.fromString(_attributeKeys.default.APP_SECTION),
  // ENV section
  ENV: AttributeName.fromString(_attributeKeys.default.ENV_SECTION),
  ENV_USER: AttributeName.fromString(_attributeKeys.default.ENV_SECTION).add(_attributeKeys.default.ENV_USER),
  ENV_USER_USER_UUID: AttributeName.fromString(_attributeKeys.default.ENV_SECTION).add(_attributeKeys.default.ENV_USER_USER_UUID),
  ENV_USER_EMAIL: AttributeName.fromString(_attributeKeys.default.ENV_SECTION).add(_attributeKeys.default.ENV_USER_EMAIL),
  ENV_USER_GROUPS: AttributeName.fromString(_attributeKeys.default.ENV_SECTION).add(_attributeKeys.default.ENV_USER_GROUPS),
  // DCL section
  DCL: AttributeName.fromString(_attributeKeys.default.DCL_SECTION),
  DCL_ACTION: AttributeName.fromString(_attributeKeys.default.DCL_SECTION).add(_attributeKeys.default.DCL_ACTION),
  DCL_RESOURCE: AttributeName.fromString(_attributeKeys.default.DCL_SECTION).add(_attributeKeys.default.DCL_RESOURCE),
  DCL_TENANT: AttributeName.fromString(_attributeKeys.default.DCL_SECTION).add(_attributeKeys.default.DCL_TENANT),
  DCL_POLICIES: AttributeName.fromString(_attributeKeys.default.DCL_SECTION).add(_attributeKeys.default.DCL_POLICIES),
  DCL_SCOPE_FILTER: AttributeName.fromString(_attributeKeys.default.DCL_SECTION).add(_attributeKeys.default.DCL_SCOPE_FILTER),
  DCL_PRINCIPAL_TO_POLICIES: AttributeName.fromString(_attributeKeys.default.DCL_SECTION).add(_attributeKeys.default.DCL_PRINCIPAL_TO_POLICIES)
};
var _default = exports.default = AttributeName;
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _comparisonoperator = _interopRequireDefault(require("./condition/comparisonoperator.js"));
var _not = _interopRequireDefault(require("./condition/not.js"));
var _or = _interopRequireDefault(require("./condition/or.js"));
var _and = _interopRequireDefault(require("./condition/and.js"));
var _true = _interopRequireDefault(require("./condition/true.js"));
var _false = _interopRequireDefault(require("./condition/false.js"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
/**
 * @typedef {import('./core/condition/condition.js').default} Condition
 */

/**
 * @param {Condition} condition 
 * @param {boolean} negated 
 * @returns {Condition}
 */
function dnf(condition, negated = false) {
  if (condition instanceof _true.default || condition instanceof _false.default) {
    return condition;
  }
  if (condition instanceof _comparisonoperator.default) {
    if (negated) {
      return _not.default.create(condition);
    }
    return condition;
  }
  if (condition instanceof _not.default) {
    return dnf(condition.condition, !negated);
  }
  if (condition instanceof _or.default && !negated || condition instanceof _and.default && negated) {
    let subDNF = condition.conditions.map(c => dnf(c, negated));
    let subconditions = [];
    for (const sc of subDNF) {
      if (sc instanceof _or.default) {
        subconditions.push(...sc.conditions);
      } else {
        subconditions.push(sc);
      }
    }
    return _or.default.create(subconditions);
  }
  if (condition instanceof _and.default && !negated || condition instanceof _or.default && negated) {
    let subDNF = condition.conditions.map(c => dnf(c, negated));

    /**
     * @type {Condition[][]}
     */
    let factors = [];
    for (const sc of subDNF) {
      if (sc instanceof _or.default) {
        factors.push(sc.conditions);
      } else {
        factors.push([sc]);
      }
    }
    let ands = multiply(factors);
    return _or.default.create(ands.map(_and.default.create));
  }
  throw new Error(`unexpected condition ${JSON.stringify(condition)}`);
}
/**
 * 
 * @param {Condition[][]} factors 
 * @returns {Condition[][]}
 */
function multiply(factors) {
  if (factors.length === 1) {
    return factors[0].map(f => [f]);
  }
  const innerResult = multiply(factors.slice(1));
  let result = [];
  for (const factor of factors[0]) {
    for (const inner of innerResult) {
      result.push([factor, ...inner]);
    }
  }
  return result;
}
var _default = exports.default = dnf;
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _dcl = require("../util/dcl.js");
var _or = _interopRequireDefault(require("./condition/or.js"));
var _policy = _interopRequireDefault(require("./policy.js"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
/**
 * @typedef {import('./core/condition/condition.js').default} Condition
 */
/**
 * @typedef {import('./schema.js').default} Schema
 */
class PolicySet {
  /**
   * @type Object.<string,Policy>
   */
  policies = {};
  /**
   * @type Object.<string,Policy>
   */
  defaultPolicies = {};
  #hasPolicies = false;

  /**
   * 
   * @param {*} dcnPolicies 
   * @param {Schema} schema 
   * @returns {PolicySet}
   */
  static fromDCN(dcnPolicies, schema) {
    let policySet = new PolicySet();
    let dcnPolicyMap = {};
    dcnPolicies.forEach(dcnPolicy => {
      const stringName = (0, _dcl.stringifyReference)(dcnPolicy.policy);
      dcnPolicyMap[stringName] = dcnPolicy;
    });
    const getResolvedPolicy = name => {
      let policy = policySet.getPolicy(name);
      if (!policy) {
        const dcnPolicy = dcnPolicyMap[name];
        if (!dcnPolicy) {
          throw new Error("unkown policy");
        }
        policy = _policy.default.fromDCN(dcnPolicy, schema, dcnPolicy?.uses?.map(u => getResolvedPolicy((0, _dcl.stringifyReference)(u.use))));
        policySet.setPolicy(name, policy);
      }
      return policy;
    };

    // initialize policySet.policies 
    for (const policyName in dcnPolicyMap) {
      getResolvedPolicy(policyName);
    }
    return policySet;
  }
  evaluate(resource, action, input = {}) {
    const rc = [];
    for (const policyName in this.policies) {
      const p = this.policies[policyName];
      const r = p.evaluate(resource, action, input);
      if (r.isTrue()) {
        return r;
      }
      if (r.isFalse()) {
        continue;
      }
      rc.push(r);
    }
    return _or.default.create(rc);
  }
  hasPolicies() {
    return this.#hasPolicies;
  }
  getPolicy(name) {
    return this.policies[name];
  }
  setPolicy(name, policy) {
    this.policies[name] = policy;
    if (policy.isDefault) {
      this.defaultPolicies[name] = policy;
    }
    this.#hasPolicies = true;
  }

  /**
   * 
   * @param {String[]} policyNames 
   * @param {boolean} includeDefault 
   * @returns {PolicySet}
   */
  getSubset(policyNames, includeDefault) {
    let policySet = new PolicySet();
    for (const name of policyNames) {
      const p = this.policies[name];
      if (!p) {
        throw new Error("unkown policy");
      }
      policySet.policies[name] = p;
    }
    if (includeDefault) {
      Object.assign(policySet.policies, this.defaultPolicies);
      policySet.defaultPolicies = this.defaultPolicies;
    }
    //policySet.condition = Or.create(Object.values(policySet.policies).map((p) => p.toCondition()));
    return policySet;
  }
}
exports.default = PolicySet;
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _nodeHttps = _interopRequireDefault(require("node:https"));
var _nodeEvents = require("node:events");
var _nodeZlib = require("node:zlib");
var _tarreader = _interopRequireDefault(require("./tarreader.js"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
/**
 * @typedef {import('node:http').IncomingMessage} IncomingMessage
 */
class BundleLoader extends _nodeEvents.EventEmitter {
  retry = {
    normal: 20000,
    short: 2000,
    threshold: 15
  };
  #bundleURL = null;
  #amsInstanceID = "";
  #httpsAgent = null;
  #etag = undefined;
  #failures = 0;
  #lastRequest = null;
  #requestTimeout = null;

  /**
   * setup the connection to bundle gateway and starts the polling for updates
   * this object will emit "change" whenever the bundle content in the upstream changed.
   * @param {*} bundleURL 
   * @param {*} amsInstanceID 
   * @param {*} certificate 
   * @param {*} key 
   */
  constructor(bundleURL, amsInstanceID, certificate, key) {
    super();
    this.#httpsAgent = new _nodeHttps.default.Agent({
      cert: certificate,
      key: key
    });
    this.#bundleURL = bundleURL;
    this.#amsInstanceID = amsInstanceID;
  }
  start() {
    if (this.#requestTimeout !== null) {
      return; // Ignore multiple start calls
    }
    this.#lastRequest = this.#load();
  }
  async stop() {
    clearTimeout(this.#requestTimeout);
    this.#requestTimeout = null;
    return this.#lastRequest;
  }
  async #load() {
    let timeout = this.retry.normal;
    try {
      const bundleStream = await this.#bundleRequest();
      this.#failures = 0;
      if (bundleStream !== null) {
        const unzip = (0, _nodeZlib.createGunzip)();
        const tarReader = new _tarreader.default();
        bundleStream.pipe(unzip).pipe(tarReader);
        this.emit("change", await tarReader.getResult());
      }
    } catch (e) {
      if (this.#failures++ < this.retry.threshold) {
        timeout = this.retry.short;
      } else {
        timeout = this.retry.normal;
      }
      this.emit("requestFailed", e);
    }
    clearTimeout(this.#requestTimeout);
    this.#requestTimeout = setTimeout(this.#load.bind(this), timeout);
  }

  /**
   * 
   * @returns {IncomingMessage}
   */
  async #bundleRequest() {
    return new Promise((resolve, reject) => {
      _nodeHttps.default.get(this.#bundleURL, {
        agent: this.#httpsAgent,
        headers: {
          "if-none-match": this.#etag ?? "",
          "x-ams-instance-id": this.#amsInstanceID
        }
      }, response => {
        if (response.statusCode === 304) {
          resolve(null);
          return;
        }
        if (response.statusCode === 200) {
          resolve(response);
          this.#etag = response.headers.etag;
          return;
        }
        // here comes the unexpected response handling
        let errorBody = "";
        response.setEncoding('utf8');
        response.on('data', chunk => {
          errorBody += chunk;
        });
        response.on("error", reject);
        response.on("end", () => reject(new Error(`unexpected status code ${response.statusCode}: ${errorBody.substring(0, 1024)}`)));
      });
    });
  }
}
exports.default = BundleLoader;
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _nodeStream = require("node:stream");
class TarReader extends _nodeStream.Writable {
  // writable stream implementation definition: https://nodejs.org/api/stream.html#api-for-stream-implementers

  #whenFinished = null;
  #result = {
    policies: [],
    schemas: [],
    // tests: [], // when we load bundles from a gateway in tar.gz, we are in a productive environment. so we will not execute tests here.
    functions: [],
    data: undefined,
    manifest: undefined // example {"revision":"fd4b6e41b4217077ca13f7c9597b994006b1d515","metadata":{"build_time":"2024-04-24T07:51:14.120064696Z"}}
  };
  constructor() {
    super();
    this.#whenFinished = new Promise((resolve, reject) => {
      this.on("finish", resolve);
      this.on("error", reject);
    });
  }
  async getResult() {
    await this.#whenFinished;
    return this.#result;
  }
  _final(done) {
    if (this.#buffer.length !== 0) {
      done(new Error("Invalid tar stream"));
    } else {
      done();
    }
  }
  #buffer = Buffer.alloc(0);
  #fileLength = 0;
  #filePadding = 0;
  #fileName = "";

  /**
   * @_param {chunk} chunk 
   * @param {Buffer} chunk 
   * @param {string} encoding
   * @param {Function} done 
   */
  _write(chunk, encoding, done) {
    this.#buffer = Buffer.concat([this.#buffer, chunk]);
    const enoughForHeader = () => this.#buffer.length >= 512 && this.#fileLength === 0;
    const enoughForFile = () => this.#fileLength > 0 && this.#buffer.length >= this.#fileLength + this.#filePadding;
    try {
      while (this.#buffer.length > 0) {
        if (enoughForHeader()) {
          this.#processHeader();
        } else if (enoughForFile()) {
          this.#processFile();
        } else {
          break;
        }
      }
      done();
    } catch (err) {
      done(err);
    }
  }
  #processHeader() {
    const filenameField = this.#buffer.subarray(0, 100);
    const nullIndex = filenameField.indexOf(0);
    if (nullIndex === -1) {
      this.#fileName = filenameField.subarray(0, 100).toString("ascii");
    } else {
      this.#fileName = filenameField.subarray(0, nullIndex).toString("ascii");
    }
    if (this.#fileName !== "") {
      this.#fileLength = parseInt(this.#buffer.subarray(124, 136).toString("ascii"), 8);
      if (isNaN(this.#fileLength)) {
        throw new Error("invalid tar header");
      }
      this.#filePadding = 512 - this.#fileLength % 512;
    }
    this.#buffer = this.#buffer.subarray(512);
  }
  #processFile() {
    // TODO: DCN Version validation

    const isDataJson = this.#fileName === "data.json";
    const isManifest = this.#fileName === ".manifest";
    const isDcnFile = this.#fileName.endsWith(".dcn");
    const isPaxHeader = this.#fileName.split("/").slice(-2, -1)[0] === "PaxHeader";
    if (!isPaxHeader && (isDataJson || isManifest || isDcnFile)) {
      const content = JSON.parse(this.#buffer.subarray(0, this.#fileLength).toString("utf-8"));
      if (isDataJson) {
        this.#result.data = content;
      } else if (isManifest) {
        this.#result.manifest = content;
      } else {
        this.#result.policies.push(...(content.policies ?? []));
        this.#result.schemas.push(...(content.schemas ?? []));
        // this.#result.tests.push(...(content.tests ?? []));
        this.#result.functions.push(...(content.functions ?? []));
      }
    }
    this.#buffer = this.#buffer.subarray(this.#fileLength + this.#filePadding);
    this.#fileLength = 0;
    this.#fileName = "";
  }
}
exports.default = TarReader;
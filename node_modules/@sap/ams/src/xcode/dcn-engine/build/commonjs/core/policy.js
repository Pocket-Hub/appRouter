"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _dcl = require("../util/dcl.js");
var _or = _interopRequireDefault(require("./condition/or.js"));
var _dcn = _interopRequireDefault(require("./dcn.js"));
var _isrestrictedprocessor = _interopRequireDefault(require("./isrestrictedprocessor.js"));
var _rule = _interopRequireDefault(require("./rule.js"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
/**
 * @typedef {import('./condition/condition.js').default} Condition
 */
/**
 * @typedef {import('./schema.js').default} Schema
 */
class Policy {
  /** 
   * @type {Rule[]}
   */
  rules = [];
  isDefault = false;
  dcnName = undefined;
  name = undefined;
  tenant = undefined;

  /**
   * @type {Condition}
   */
  rulesAsCondition = undefined;
  /**
   * 
   * @param {*} dcnPolicy 
   * @param {Schema} schema 
   * @param {Policy[]} usedPolicies 
   * @returns {Policy}
   */
  static fromDCN(dcnPolicy, schema, usedPolicies) {
    const policy = new Policy();
    policy.rules = dcnPolicy?.rules?.map(dcnRule => _rule.default.fromDCN(dcnRule, schema)) ?? [];
    policy.isDefault = dcnPolicy.default;
    policy.dcnName = dcnPolicy.policy;
    policy.tenant = schema.getTenantOfPolicy(policy.dcnName);
    policy.name = (0, _dcl.stringifyReference)(policy.dcnName);
    for (const use of dcnPolicy.uses ?? []) {
      let restrictionsPerVariable = {};
      for (const restriction of use.restrictions ?? []) {
        for (const r of restriction) {
          const rc = _dcn.default.condition(r, schema);
          for (const v of rc.variables) {
            if (!restrictionsPerVariable[v]) {
              restrictionsPerVariable[v] = [];
            }
            restrictionsPerVariable[v].push(rc);
          }
        }
      }
      let restrictions = {};
      for (const v in restrictionsPerVariable) {
        restrictions[v] = _or.default.create(restrictionsPerVariable[v]);
      }
      const useName = (0, _dcl.stringifyReference)(use.use);
      const usedPolicy = usedPolicies.find(p => p.name == useName);
      if (!usedPolicy) {
        throw new Error(`could not find used policy ${use.use}`);
      }
      for (const r of usedPolicy.rules) {
        let usedRule = new _rule.default();
        usedRule.actions = r.actions;
        usedRule.resources = r.resources;
        usedRule.condition = (0, _isrestrictedprocessor.default)(r.condition, restrictions);
        usedRule.fromUse = r.fromUse.concat([useName]);
        policy.rules.push(usedRule);
      }
    }
    policy.rulesAsCondition = _or.default.create(policy.rules.map(r => r.toCondition()));
    return policy;
  }

  /**
   * @returns {Condition}
    */
  evaluate(resource, action, input = {}) {
    input["$dcl.resource"] = resource;
    input["$dcl.action"] = action;
    return this.rulesAsCondition.evaluate(input);
  }
}
exports.default = Policy;
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _nodeEvents = _interopRequireDefault(require("node:events"));
var _authorizationmanager = _interopRequireDefault(require("./authorizationmanager.js"));
var _attributes = _interopRequireDefault(require("./legacy/attributes.js"));
var _dcl = require("./util/dcl.js");
var _nodeOs = require("node:os");
var _tranformer = require("./legacy/tranformer.js");
var _bundleloader = _interopRequireDefault(require("./bundle/bundleloader.js"));
var _promises = _interopRequireDefault(require("node:fs/promises"));
var _nodePath = _interopRequireDefault(require("node:path"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
const VERSION = "dcn.opa.emulator:17.0.2";
const DEFAULT_DCL_PACKAGE = "dcr._default_";
const IDENTITY_SECRET_DIR = "/etc/secrets/sapbtp/identity";
class PolicyDecisionPoint extends _nodeEvents.default {
  /**
   * @type {AuthorizationManager}
   */
  _authorizationManager = new _authorizationmanager.default();

  /**
   * @type {BundleLoader}
   */
  _bundleLoader = null;
  /**
   * If none url is specified takes the OPA URL from env var with key OPA_URL_ENV_KEY
   * If none env var is specified takes the default OPA URL OPA_URL_DEFAULT
   * @param {String} url takes as argument the OPA URL
   * @param {number} timeout defines the connection timeout (ms) to pdp: 0 indicates no timeout
   */
  constructor(url, timeout, authorizationManager = null) {
    super();
    if (authorizationManager) {
      this._authorizationManager = authorizationManager;
    } else {
      this._bundleLoader = new _bundleloader.default();
      this._bundleLoader.on("change", bundleContent => {
        this._authorizationManager.updateBundle(bundleContent);
      });
      if (process.env.VCAP_SERVICES) {
        this.#fromCF();
      } else {
        this.#fromK8s();
      }
    }
  }

  /**
   * Checks if access can be granted.
   * Ignore elements are removed as if they where not present in the DCL rules.
   * Note: if ignore values are set the endpoint is changed from METHOD_ALLOW to
   * METHOD_ALLOW_PARTIAL to be able to process ignore values, this will also
   * lead to a performance decrease
   * @param {Attributes} attr
   * @param {String} dclPackage
   * @throws {Error} if no attributes are specified
   * @return {boolean} result as boolean
   */
  async allow(attr) {
    if (!attr) {
      throw new Error("No attributes specified in pdp allow request");
    }
    const unknowns = attr.getUnknowns().map(attrName => attrName.getSegments());
    const ignores = attr.getIgnores().map(attrName => attrName.getSegments());
    const input = {
      $app: attr.getApp(),
      $env: attr.getEnv()
    };
    const dcl = attr.getDcl();
    const decision = await this._authorizationManager.__internal_genericInquiry(dcl, unknowns, ignores, input);
    const result = decision.isGranted();
    const attributesJSON = {}; // attr.getJSON();
    const tokenClientId = attr.getTokenInfo()?.getClientId() ?? null;
    this.emit("allow", {
      "operation": "allow",
      // Name of the event
      "result": result,
      // response from pdp
      "attributesJSON": attributesJSON,
      // attributes sent to the pdp if any
      "dclPackage": DEFAULT_DCL_PACKAGE,
      // set DCL package
      "isSucceeded": true,
      // boolean - false if an error has occurred
      "tokenClientId": tokenClientId
    });
    this.emit("pdpEvaluation", {
      "operation": "allow",
      // Name of the event
      "result": result,
      // response from pdp
      "attributesJSON": attributesJSON,
      // attributes sent to the pdp if any
      "dclPackage": DEFAULT_DCL_PACKAGE,
      // set DCL package
      "isSucceeded": true,
      // boolean - false if an error has occurred
      "tokenClientId": tokenClientId
    });
    this.emit("amsPolicyEvaluation", {
      "operation": "allow",
      // Name of the event
      "result": result,
      // response from pdp
      "attributesJSON": attributesJSON,
      // attributes sent to the pdp if any
      "dclPackage": DEFAULT_DCL_PACKAGE,
      // set DCL package
      "isSucceeded": true,
      // boolean - false if an error has occurred
      "tokenClientId": tokenClientId
    });
    return result;
  }

  /**
   * Computes the FilterClause.
   * The unknown Attributes determine which elements should be in the filter clause.
   * Ignore elements are removed as if they where not present in the DCL rules.
   * @param {Attributes} attributes
   * @param {String} dclPackage
   * @throws {Error} if no attributes are specified
   * @return {Promise} {condition: "", unknowns: "", ignores: ""} 
   */
  async allowFilterClause(attr) {
    if (!attr) {
      throw new Error("No attributes specified in pdp allowFilter request");
    }
    const unknowns = attr.getUnknowns().map(attrName => attrName.getSegments());
    const ignores = attr.getIgnores().map(attrName => attrName.getSegments());
    const input = {
      $app: attr.getApp(),
      $env: attr.getEnv()
    };
    const dcl = attr.getDcl();
    const decision = await this._authorizationManager.__internal_genericInquiry(dcl, unknowns, ignores, input);
    const opaResult = (0, _tranformer.emulateOPA)(decision);
    const attributesJSON = {}; // attr.getJSON();
    const tokenClientId = attr.getTokenInfo()?.getClientId() ?? null;
    this.emit("allowPartial", {
      "operation": "allowPartial",
      // Name of the event
      "result": opaResult,
      // response from pdp
      "attributesJSON": attributesJSON,
      // attributes sent to the pdp if any
      "dclPackage": DEFAULT_DCL_PACKAGE,
      // set DCL package
      "isSucceeded": true,
      // boolean - false if an error has occurred
      "tokenClientId": tokenClientId
    });
    this.emit("pdpEvaluation", {
      "operation": "allowPartial",
      // Name of the event
      "result": opaResult,
      // response from pdp
      "attributesJSON": attributesJSON,
      // attributes sent to the pdp if any
      "dclPackage": DEFAULT_DCL_PACKAGE,
      // set DCL package
      "isSucceeded": true,
      // boolean - false if an error has occurred
      "tokenClientId": tokenClientId
    });
    this.emit("amsPolicyEvaluation", {
      "operation": "allowPartial",
      // Name of the event
      "result": opaResult,
      // response from pdp
      "attributesJSON": attributesJSON,
      // attributes sent to the pdp if any
      "dclPackage": DEFAULT_DCL_PACKAGE,
      // set DCL package
      "isSucceeded": true,
      // boolean - false if an error has occurred
      "tokenClientId": tokenClientId
    });
    return {
      "condition": opaResult
      // "unknowns": attr.getUnknowns().map((attrName) => { return attrName.toString(); }),
      // "ignores": attr.getIgnores().map((attrName) => { return attrName.toString(); })
    };
  }

  /**
   * Tests for connectivity to the runtime.
   * This method does not throw any.
   * If the reason for a failure needs to be known use ping with
   * the required DCL package of your application.
   * @return {bool}
   */
  async isReachable() {
    const result = this._authorizationManager.hasPolicies();
    this.emit("ping", {
      "operation": "ping",
      // Name of the event
      "result": result,
      // response from pdp
      "attributesJSON": {},
      // attributes sent to the pdp if any
      "dclPackage": DEFAULT_DCL_PACKAGE,
      // set DCL package
      "isSucceeded": result,
      // boolean - false if an error has occurred
      "tokenClientId": null
    });
    this.emit("pdpEvaluation", {
      "operation": "ping",
      // Name of the event
      "result": result,
      // response from pdp
      "attributesJSON": {},
      // attributes sent to the pdp if any
      "dclPackage": DEFAULT_DCL_PACKAGE,
      // set DCL package
      "isSucceeded": result,
      // boolean - false if an error has occurred
      "tokenClientId": null
    });
    return result;
  }

  /**
   * Determine health state
   * see: https://github.wdf.sap.corp/CPSecurity/cas-opa-sap#bundle-status-endpoint
   * @return {PolicyDecisionPoint.HealthState}
   */
  async getHealthStatus() {
    let result;
    //TODO handle errors
    if (this._authorizationManager.hasPolicies()) {
      result = PolicyDecisionPoint.HealthState.OK;
    } else {
      result = PolicyDecisionPoint.HealthState.NOT_READY;
    }
    this.emit("getStatus", {
      "operation": "getStatus",
      // Name of the event
      "result": result,
      // response from pdp
      "attributesJSON": {},
      // attributes sent to the pdp if any
      "dclPackage": DEFAULT_DCL_PACKAGE,
      // set DCL package
      "isSucceeded": result,
      // boolean - false if an error has occurred
      "tokenClientId": null
    });
    this.emit("pdpEvaluation", {
      "operation": "getStatus",
      // Name of the event
      "result": result,
      // response from pdp
      "attributesJSON": {},
      // attributes sent to the pdp if any
      "dclPackage": DEFAULT_DCL_PACKAGE,
      // set DCL package
      "isSucceeded": result,
      // boolean - false if an error has occurred
      "tokenClientId": null
    });
    return result;
  }

  /**
   * resolves when pdp is healthy
   * @param {number} timeout in milliseconds
   * @param {boolean} failOnStartupCheck throws error if not HealthState.OK
   * @return {PolicyDecisionPoint.HealthState}
  */
  async startupCheck(timeout, failOnStartupCheck = true) {
    return new Promise((resolve, reject) => {
      const onTimeout = () => {
        const healthState = this.getHealthStatus();
        if (failOnStartupCheck) {
          reject(new Error(`Bundle download failed, total wait time ${timeout} reached, state: ${healthState}`));
        } else {
          resolve(healthState);
        }
      };
      setTimeout(onTimeout, timeout);
      this._authorizationManager.whenReady().then(() => resolve(PolicyDecisionPoint.HealthState.OK));
    });
  }

  /**
   * Tests for existence of the dclPackage (default if not provided) and
   * implicitly checks the connectivity to the runtime.
   * @param {String} dclPackage
   * @param {number} timeout defines the connection timeout (ms) to pdp: 0 indicates no timeout
   * @throws {DCLPackageNameError} if package is not qualified
   * @throws {OpaConnError} if opa is not reachable
   * @throws {DCLError} if opa does not return true
   * @return {Boolean} true if ping was successful
   */
  async ping(dclPackage = DEFAULT_DCL_PACKAGE) {
    const result = this._authorizationManager.hasPolicies();
    this.emit("ping", {
      "operation": "ping",
      // Name of the event
      "result": result,
      // response from pdp
      "attributesJSON": {},
      // attributes sent to the pdp if any
      "dclPackage": dclPackage,
      // set DCL package
      "isSucceeded": result,
      // boolean - false if an error has occurred
      "tokenClientId": null
    });
    this.emit("pdpEvaluation", {
      "operation": "ping",
      // Name of the event
      "result": result,
      // response from pdp
      "attributesJSON": {},
      // attributes sent to the pdp if any
      "dclPackage": dclPackage,
      // set DCL package
      "isSucceeded": result,
      // boolean - false if an error has occurred
      "tokenClientId": null
    });
    if (result === true) {
      return true;
    }
    throw new Error(`Opa responded with: for ping on package: "${dclPackage}"`, 400);
  }

  /**
   * The format is not guaranteed.
   * @return {String} version string
   */
  async getVersion() {
    this.emit("getVersion", {
      "operation": "getVersion",
      // Name of the event
      "result": VERSION,
      // response from pdp
      "attributesJSON": {},
      // attributes sent to the pdp if any
      "dclPackage": null,
      // set DCL package
      "isSucceeded": true,
      // boolean - false if an error has occurred
      "tokenClientId": null
    });
    this.emit("pdpEvaluation", {
      "operation": "getVersion",
      // Name of the event
      "result": VERSION,
      // response from pdp
      "attributesJSON": {},
      // attributes sent to the pdp if any
      "dclPackage": null,
      // set DCL package
      "isSucceeded": true,
      // boolean - false if an error has occurred
      "tokenClientId": null
    });
    return VERSION;
  }
  async #fromK8s() {
    const secretDir = await _promises.default.readdir(IDENTITY_SECRET_DIR);
    if (secretDir.length > 1) {
      throw new Error(`more than one 'identity' secret found in ${IDENTITY_SECRET_DIR}: ${JSON.stringify(secretDir)} `);
    }
    if (secretDir.length < 1) {
      throw new Error(`no 'identity' secret found in ${IDENTITY_SECRET_DIR}`);
    }
    const secretPath = _nodePath.default.join(IDENTITY_SECRET_DIR, secretDir[0]);
    const s = JSON.stringify(await _promises.default.readFile(secretPath, "utf-8"));
    this._bundleLoader.setupMTLS(new URL(`${s.authorization_bundle_url}/${s.authorization_instance_id}.dcn.tar.gz`), s.authorization_instance_id, s.certificate, s.key);
  }
  async #fromCF() {
    const vcapServices = JSON.parse(process.env.VCAP_SERVICES);
    let services = [];
    const userProvidedServices = vcapServices["user-provided"];
    if (Array.isArray(userProvidedServices)) {
      services = userProvidedServices.filter(ups => ups.name === "identity" || Array.isArray(ups.tags) && ups.tags.includes("identity"));
    }
    if (Array.isArray(vcapServices["identity"])) {
      services.push(...vcapServices["identity"]);
    }
    if (services.length > 1) {
      throw new Error(`more than one 'identity' service found in VCAP_SERVICES ${JSON.stringify(services)} `);
    }
    if (services.length < 1) {
      throw new Error(`no 'identity' service found in VCAP_SERVICES`);
    }
    const s = services[0].credentials;
    this._bundleLoader.setupMTLS(new URL(`${s.authorization_bundle_url}/${s.authorization_instance_id}.dcn.tar.gz`), s.authorization_instance_id, s.certificate, s.key);
  }
}
PolicyDecisionPoint.HealthState = {
  OK: "ok",
  UNREACHABLE: "unreachable",
  FATAL: "fatal",
  UPDATE_FAILED: "update_failed",
  NOT_READY: "not_ready"
};
var _default = exports.default = PolicyDecisionPoint;
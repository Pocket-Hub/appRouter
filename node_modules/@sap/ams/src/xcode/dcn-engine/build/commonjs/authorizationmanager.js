"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _policyassignments = _interopRequireDefault(require("./bundle/policyassignments.js"));
var _and = _interopRequireDefault(require("./core/condition/and.js"));
var _in = _interopRequireDefault(require("./core/condition/in.js"));
var _is_null = _interopRequireDefault(require("./core/condition/is_null.js"));
var _or = _interopRequireDefault(require("./core/condition/or.js"));
var _value = _interopRequireDefault(require("./core/condition/value.js"));
var _policyset = _interopRequireDefault(require("./core/policyset.js"));
var _schema = _interopRequireDefault(require("./core/schema.js"));
var _decision = _interopRequireDefault(require("./decision.js"));
var _library = require("./library.js");
var _authorizations = _interopRequireDefault(require("./authorizations.js"));
var _dcl = require("./util/dcl.js");
var _equal = _interopRequireDefault(require("./core/condition/equal.js"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
class AuthorizationManager {
  #whenReady = null;
  /**
   * all policies of bundle
   * @type {PolicySet}
   */
  #policySet = null;
  /**
   * @type {Schema}
   */
  #schema = null;
  /**
   * @type {PolicyAssignments}
   */
  #policyAssignments = null;
  #fnWhenReady = null;
  #ready = false;

  /**
   * @type {import("./decision.js").Condition}
   */
  #genericCondition = null;
  #principal2policies = null;
  constructor(bundleContent = null) {
    this.#whenReady = new Promise(resolve => {
      this.#fnWhenReady = resolve;
    }).then(() => {
      this.#ready = true;
    });
    if (bundleContent !== null) {
      this.updateBundle(bundleContent);
    }
  }
  async updateBundle(bundleContent) {
    this.#schema = _schema.default.fromDCN(bundleContent.schemas, bundleContent.functions);
    this.#policySet = _policyset.default.fromDCN(bundleContent.policies, this.#schema);
    this.#policyAssignments = new _policyassignments.default(bundleContent.data);
    this.#principal2policies = bundleContent.data ? bundleContent.data.principal2policies : {};
    this.#genericCondition = null;
    this.#fnWhenReady();
    return this.#whenReady;
  }
  hasPolicies() {
    return !!this.#policySet?.hasPolicies();
  }
  isReady() {
    return this.#ready;
  }
  async whenReady() {
    return this.#whenReady;
  }
  getPrincipal2Policies() {
    if (!this.#ready) {
      throw new Error("no authorization data loaded");
    }
    return this.#principal2policies;
  }

  /**
   * @param {String[]} principal 
   * @returns {Authorizations}
   */
  getPrincipalAccess(principal, scopeFilter = []) {
    if (!this.#ready) {
      throw new Error("no authorization data loaded");
    }
    const policyNames = this.#policyAssignments.getPolicyNames(principal);
    return this.getPoliciesAccess(policyNames, scopeFilter);
  }
  /**
   * @param {String[]} policyNames 
   * @returns {Authorizations}
  */
  getPoliciesAccess(policyNames, scopeFilter = []) {
    if (!this.#ready) {
      throw new Error("no authorization data loaded");
    }
    let result = new _authorizations.default();
    let withScopeFilter = scopeFilter.length !== 0;
    result.__internal__policyset = this.#policySet.getSubset(policyNames, true);
    if (withScopeFilter) {
      result.__internal__scopefilter__policyset = this.#policySet.getSubset(scopeFilter, false);
    }
    return result;
  }

  /**
   * @deprecated do not use. this approach is to emulate the full DCN functionality and is hardly performant.
   * @param {Object} input 
   * @param {*} dcl 
   * @returns {Decision}
   */
  __internal_genericInquiry(dcl, unkown, ignore, input) {
    if (!this.#ready) {
      throw new Error("no authorization data loaded");
    }
    if (!dcl) {
      dcl = {
        "policies": []
      };
    } else if (!dcl.policies && dcl.principal2policies) {
      // todo clarify all side effect of complex parametrization
      dcl.policies = this.#policyAssignments.getPolicyNames(dcl.principal2policies);
    }
    const ignoreExp = this.#schema.expandAndFlattenVariableList(ignore);
    const unkownExp = this.#schema.expandAndFlattenVariableList(unkown);

    // modelling https://github.wdf.sap.corp/CPSecurity/cas-dcl-ide/blob/master/documentation/DCLNotation.md#evaluating-assigned-policy-default-policy-scopefilter

    if (ignoreExp.includes("$dcl.tenant")) {
      throw new Error("ignore '$dcl.tenant' not allowed");
    }
    if (ignoreExp.includes("$dcl.policies")) {
      throw new Error("ignore '$dcl.policies' not allowed");
    }
    if (ignoreExp.includes("$dcl.scopeFilter")) {
      throw new Error("ignore '$dcl.scopeFilter' not allowed");
    }
    if (ignoreExp.includes("$dcl.principal2policies")) {
      throw new Error("ignore '$dcl.principal2policies' not allowed");
    }
    if (!this.#genericCondition) {
      this.#genericCondition = this.#createGenericCondition();
    }
    let fullInput = this.#schema.validateAndFlattenInput(input);
    fullInput["$dcl.scopeFilter"] = undefined; // Explicitly set undefined so the scopefilter condition evaluetes to True directly
    for (const key in dcl) {
      if (key === "scopeFilter" || key === "policies") {
        fullInput[`$dcl.${key}`] = dcl[key].map(e => Array.isArray(e) ? (0, _dcl.stringifyReference)(e) : e);
      } else {
        fullInput[`$dcl.${key}`] = dcl[key];
      }
    }
    for (const variable of ignoreExp) {
      delete fullInput[variable];
    }
    for (const variable of unkownExp) {
      delete fullInput[variable];
    }
    let result = new _decision.default();
    result.__internal__condition = this.#genericCondition.evaluate(fullInput);
    return (0, _library.processUnknownIgnore)(result, unkownExp, ignoreExp);
  }

  /**
   * @returns {import("./decision.js").Condition}
   */
  #createGenericCondition() {
    const policiesConds = [];
    const scopeFilterConds = [new _is_null.default(_value.default.fromDcn({
      ref: ["$dcl", "scopeFilter"]
    }))];
    for (const k in this.#policySet.policies) {
      const p = this.#policySet.policies[k];
      const policyConds = [];
      if (p.tenant) {
        policyConds.push(new _equal.default(_value.default.fromDcn(p.tenant), _value.default.fromDcn({
          ref: ["$dcl", "tenant"]
        })));
      }
      if (!p.isDefault) {
        policyConds.push(new _in.default(_value.default.fromDcn(p.name), _value.default.fromDcn({
          ref: ["$dcl", "policies"]
        })));
      }
      policyConds.push(p.rulesAsCondition);
      policiesConds.push(_and.default.create(policyConds));
      scopeFilterConds.push(_and.default.create([new _in.default(_value.default.fromDcn(p.name), _value.default.fromDcn({
        ref: ["$dcl", "scopeFilter"]
      })), p.rulesAsCondition]));
    }
    return new _and.default([_or.default.create(scopeFilterConds), _or.default.create(policiesConds)]);
  }
}
exports.default = AuthorizationManager;
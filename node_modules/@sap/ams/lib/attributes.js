"use strict";

const AttributeName = require("./attributeName");
const attrKeys = require("./attributeKeys");

function Attributes(other) {
	let _json = {};
	let _tokenInfo = null;

	// copy constructor
	if (other instanceof Attributes) {
		const stringify = false;
		_json = other.getJSON(stringify);
	}

	function dcl() {
		if(!_json[attrKeys.DCL_SECTION]) {
			_json[attrKeys.DCL_SECTION] = {};
		}
		return _json[attrKeys.DCL_SECTION];
	}
	function app() {
		if(!_json[attrKeys.APP_SECTION]) {
			_json[attrKeys.APP_SECTION] = {};
		}        
		return _json[attrKeys.APP_SECTION];
	}
	function env() {
		if(!_json[attrKeys.ENV_SECTION]) {
			_json[attrKeys.ENV_SECTION] = {};
		}
		return _json[attrKeys.ENV_SECTION];
	}
	function unknowns() {
		if(!_json[attrKeys.UNKNOWNS_SECTION]) {
			_json[attrKeys.UNKNOWNS_SECTION] = [];
		}
		return _json[attrKeys.UNKNOWNS_SECTION];
	}
	function ignores() {
		if(!_json[attrKeys.IGNORES_SECTION]) {
			_json[attrKeys.IGNORES_SECTION] = [];
		}
		return _json[attrKeys.IGNORES_SECTION];
	}
	function dollarUser() {
		if(!env()[attrKeys.ENV_USER]) {
			env()[attrKeys.ENV_USER] = {};
		}
		return env()[attrKeys.ENV_USER];
	}

	/**
	 * @param {String} action
	 */
	this.setAction = function(action) {
		dcl()[attrKeys.DCL_ACTION] = action;
		return this;
	};

	/**
	 * @return {String} empty string if not set
	 */
	this.getAction = function() {
		if(!dcl()[attrKeys.DCL_ACTION]) {
			return "";
		}
		return dcl()[attrKeys.DCL_ACTION];
	};

	/**
	 * @param {String} resource
	 */
	this.setResource = function(resource) {
		dcl()[attrKeys.DCL_RESOURCE] = resource;
		return this;
	};

	/**
	 * @return {String} empty string if not set
	 */
	this.getResource = function() {
		if(!dcl()[attrKeys.DCL_RESOURCE]) {
			return "";
		}
		return dcl()[attrKeys.DCL_RESOURCE];
	};

	/**
	 * @param {String} tenant
	 */
	this.setTenant = function(tenant) {
		dcl()[attrKeys.DCL_TENANT] = tenant;
		return this;
	};

	/**
	 * @return {String} empty string if not set
	 */
	this.getTenant = function() {
		if(!dcl()[attrKeys.DCL_TENANT]) {
			return "";
		}
		return dcl()[attrKeys.DCL_TENANT];
	};

	/**
	 * Note that if policies was set before it will be removed from
	 * attributes JSON, because only one of the entries can be valid.
	 * Please use the ias scim_id instead of the user_uuid
	 * @param {Array} keys e.g.: ["zone_a","ias_scim_id"]
	 */
	this.setPrincipalToPolicies = function(keys) {
		if(!keys) {
			delete dcl()[attrKeys.DCL_PRINCIPAL_TO_POLICIES];
			return this;
		}

		const items = Array.isArray(keys) ? keys : [keys];
		dcl()[attrKeys.DCL_PRINCIPAL_TO_POLICIES] = items;
		delete dcl()[attrKeys.DCL_POLICIES];
		return this;
	};

	/**
	 * @return {Array} empty array if not set
	 * e.g. ["zone_a","ias_scim_id"]
	 */
	this.getPrincipalToPolicies = function() {
		if(!dcl()[attrKeys.DCL_PRINCIPAL_TO_POLICIES]) {
			return [];
		}
		return dcl()[attrKeys.DCL_PRINCIPAL_TO_POLICIES];
	};

	/**
	 * Sets the policies Array.
	 * Note that the policies have to be prefixed with the DCL
	 * package(s) e.g. ["ams.readAllSalesOrders"]
	 * Also note that if principal2policies was set before it will be removed, because
	 * only one of the entries can be valid.
	 * @param {Array} key a list of policies
	 */
	this.setPolicies = function(keys) {
		if(!keys) {
			delete dcl()[attrKeys.DCL_POLICIES];
			return this;
		}

		const items = Array.isArray(keys) ? keys : [keys];
		dcl()[attrKeys.DCL_POLICIES] = items;
		delete dcl()[attrKeys.DCL_PRINCIPAL_TO_POLICIES];
		return this;
	};

	/**
	 * @return {Array} empty array if not set
	 */
	this.getPolicies = function() {
		if(!dcl()[attrKeys.DCL_POLICIES]) {
			return [];
		}
		return dcl()[attrKeys.DCL_POLICIES];
	};

	/**
	 * Sets scope filtering policies.
	 * This is for scenarios where an additional filters need to be applied.
	 * Logically the result is computed by doing
	 * an AND to the list of qualifiedPolicies that are combined with OR.
	 * @param {Array} key a list of policies
	 */
	this.setScopeFilterPolicies = function(keys) {
		if(!keys) {
			delete dcl()[attrKeys.DCL_SCOPE_FILTER];
			return this;
		}

		const items = Array.isArray(keys) ? keys : [keys];
		dcl()[attrKeys.DCL_SCOPE_FILTER] = items;
		return this;
	};

	/**
	 * @return {Array} empty array if not set
	 */
	this.getScopeFilterPolicies = function() {
		if(!dcl()[attrKeys.DCL_SCOPE_FILTER]) {
			return [];
		}
		return dcl()[attrKeys.DCL_SCOPE_FILTER];
	};

	/**
	 * @return {Object} returns the $dcl section of attributes
	 */
	this.getDcl = function() {
		return dcl();
	};

	/**
	 * @param {Object} pairs app key value pairs e.g. {"country": "DE"}
	 */
	this.setApp = function(pairs) {
		if(_json && pairs) {
			_json[attrKeys.APP_SECTION] = pairs;
		}

		return this;
	};

	/**
	 * @return {Object} returns the $app section of attributes
	 */
	this.getApp = function() {
		return app();
	};

	/**
	 * @param {Object} pairs env key value pairs
	 * example for setting $user.country = A :
	 * setEnv({
	 *			"$user": {
	 *				"country": "A"
	 *			},
	 *		})
	 */
	this.setEnv = function(pairs) {
		if(_json && pairs) {
			_json[attrKeys.ENV_SECTION] = pairs;
		}

		return this;
	};

	this.getEnv = function() {
		return env();
	};

	this.setUserUuid = function(uuid) {
		dollarUser()[attrKeys.ENV_USER_USER_UUID] = uuid;
		return this;
	};

	this.getUserUuid = function() {
		if(!dollarUser()[attrKeys.ENV_USER_USER_UUID]) {
			return "";
		}
		return dollarUser()[attrKeys.ENV_USER_USER_UUID];
	};

	this.setEmail = function(email) {
		dollarUser()[attrKeys.ENV_USER_EMAIL] = email;
		return this;
	};

	this.getEmail = function() {
		if(!dollarUser()[attrKeys.ENV_USER_EMAIL]) {
			return "";
		}
		return dollarUser()[attrKeys.ENV_USER_EMAIL];
	};

	this.setGroups = function(groups) {
		if(!groups) {
			return this;
		}
		const items = Array.isArray(groups) ? groups : [groups];
		dollarUser()[attrKeys.ENV_USER_GROUPS] = items;
		return this;
	};

	this.getGroups = function() {
		if(!dollarUser()[attrKeys.ENV_USER_GROUPS]) {
			return [];
		}
		return dollarUser()[attrKeys.ENV_USER_GROUPS];
	};

	/**
	 * Internally transforms the param Arrays to AttributeName Object(s)
	 * @param {Array of Strings or AttributeNames} unknowns
	 * attributeNames e.g. "addUnknowns(["$app","country"])"
	 * or multiple attributeNames e.g. "addUnknowns(["$app"], ["$env","$user"])
	 * or directly use AttributeNames e.g. "addUnknowns(AttributeName.fromArray(["$app","country"]))"
	 * or if possible from constant e.g. "addUnknowns(AttributeName.common.APP, AttributeName.common.ENV)"
	 */
	this.addUnknowns = function(...unknownsArr) {
		// from AttributeNames
		if (AttributeName.isAttributeName(unknownsArr[0])) {
			_json[attrKeys.UNKNOWNS_SECTION] = unknowns().concat(unknownsArr);
		} else {
			// from Array
			addUnknownsOrIgnoresFromArray(unknownsArr, attrKeys.UNKNOWNS_SECTION);
		}
		return this;
	};

	/**
	 * Overwrites the unknowns section in attributes
	 * Can take multiple unknowns e.g.: [["$app","country"],["$env","$user"]]
	 * Internally transforms the params to AttributeName Object(s)
	 * Or directly use AttributeNames e.g. "setUnknowns(AttributeName.fromArray(["$app","country"]))"
	 * @param {Array of Array of Strings} stringsArrays
	 */
	this.setUnknowns = function(unknowns) {
		// from AttributeNames
		if (AttributeName.isAttributeName(unknowns) || 
			(Array.isArray(unknowns) && AttributeName.isAttributeName(unknowns[0]))) {
			_json[attrKeys.UNKNOWNS_SECTION] = Array.isArray(unknowns) ? unknowns : [unknowns];
		} else {
			// from Array
			unknowns = makeArrayTwoDimensional(unknowns);
			setUnknownsOrIgnoresFromArray(unknowns, attrKeys.UNKNOWNS_SECTION);
		}
		return this;
	};

	/**
	 * returns the set AttributeNames as array
	 * @return {Array of AttributeName Objects}
	 * Note: use getUnknowns.map(attrName => {attrName.toString()}) to get the string representation
	 */
	this.getUnknowns = function() {
		return unknowns();
	};

	/**
	 * Internally transforms the params to AttributeName Object(s)
	 * @param {Arrays of Arrays of Strings} stringsArrays
	 * attributeNames e.g. "addIgnores(["$app","country"])"
	 * or multiple attributeNames e.g. "addIgnores(["$app"], "["$env","$user"])
	 * or directly use AttributeNames e.g. "addIgnores(AttributeName.fromArray(["$app","country"]))"
	 * or if possible from constant e.g. "addIgnores(AttributeName.common.APP, AttributeName.common.ENV)"
	 */
	this.addIgnores = function(...ignoresArr) {
		// from AttributeNames
		if (AttributeName.isAttributeName(ignoresArr[0])) {
			_json[attrKeys.IGNORES_SECTION] = ignores().concat(ignoresArr);
		} else {
			// from Array
			addUnknownsOrIgnoresFromArray(ignoresArr, attrKeys.IGNORES_SECTION);
		}
		return this;
	};

	/**
	 * Overwrites the ignores section in attributes
	 * Can take multiple AttributeNames e.g.: [["$app","country"],["$env","$user"]]
	 * Internally transforms the params to AttributeName Object(s)
	 * Or directly use AttributeNames e.g. "setIgnores(AttributeName.fromArray(["$app","country"]))"
	 * @param {Arrays of Arrays of Strings} stringsArrays
	 */
	this.setIgnores = function(ignores) {
		// from AttributeNames
		if (AttributeName.isAttributeName(ignores) || 
			(Array.isArray(ignores) && AttributeName.isAttributeName(ignores[0]))) {
			_json[attrKeys.IGNORES_SECTION] = Array.isArray(ignores) ? ignores : [ignores];
		} else {
			// from Array
			ignores = makeArrayTwoDimensional(ignores);
			setUnknownsOrIgnoresFromArray(ignores, attrKeys.IGNORES_SECTION);
		}
		return this;
	};

	/**
	 * returns the set AttributeNames as array
	 * @return {Array of AttributeName Objects}
	 * Note: use getIgnores.map(attrName => {attrName.toString()}) to get the string representation
	 */
	this.getIgnores = function() {
		return ignores();
	};

	/**
	 * Sets all information that can be retrieved from token. this includes
	 * principal2policies: ["zone_id","user_id"]
	 * tenant: "zone_id"
	 * $user: { // Default $user definition. This is injected, if no custom $user definition is present
	 *  user_uuid: String,
	 *  groups: String[],
	 *  email: String
	 * }
	 * @param {Object} tokenInfo object retrieved by the xsec lib
	 */
	this.setTokenInfo = function(tokenInfo) {
		const userUuid = tokenInfo.getUserId();
		const zoneId = tokenInfo.getAppTID();
		const scimId = tokenInfo.getPayload().scim_id; // TODO replace with dedicated function
		const email = tokenInfo.getPayload().email;
		const groups = tokenInfo.getPayload().groups;

		// set $dcl section
		if (zoneId && scimId) this.setPrincipalToPolicies([zoneId, scimId]);
		else if (zoneId && userUuid) this.setPrincipalToPolicies([zoneId, userUuid]);
		if (zoneId) this.setTenant(zoneId);

		// set $env section
		if (userUuid) this.setUserUuid(userUuid);
		if (email) this.setEmail(email);
		if (groups) this.setGroups(Array.isArray(groups)? groups : [groups]);

		// add tokenInfo to retrieve clientId in auditlogging
		_tokenInfo = tokenInfo;

		return this;
	};

	this.getTokenInfo = function() {
		return _tokenInfo;
	};

	/**
	 * @param {bool} stringify unknowns and ignores are stored as AttributeNames
	 * 	if this value is set to true (default), those will get transformed to strings.
	 * 	Also empty json values will be deleted
	 * @return {object} returns the whole attribute as JSON object
	 */
	this.getJSON = function(stringify = true) {
		return cleanUpJson(_json, stringify, this.getUnknowns(), this.getIgnores());
	};

	/**
	 * Returns a formatted JSON string representation of the attribute content.
	 */
	this.toString = function() {
		return JSON.stringify(this.getJSON(), null, "  ");
	}

	// helper functions for ignores and unknowns
	function addUnknownsOrIgnoresFromArray(inputArray, key) {
		if (! _json[key]) _json[key] = [];
		if (inputArray.length > 0) {
			_json[key] = _json[key].concat(
				inputArray.map((stringArray) => {
					return AttributeName.fromArray(stringArray);
				})
			);
		}
	}
	function setUnknownsOrIgnoresFromArray(inputArray, key) {
		_json[key] = inputArray.map((stringArray) => {
			return AttributeName.fromArray(stringArray);
		});
	}
}

/**
 * removes every empty entry in json
 */
function cleanUpJson(obj, stringify, thisUnknowns, thisIgnores) {
	const copy = JSON.parse(JSON.stringify(obj));
	// manually copy unknowns and ignores because they are objects and were removed by the line above
	const copyAttrName = (attrName) => {
		if (stringify) return attrName.toString();
		return new AttributeName(attrName);
	};
	if (thisUnknowns) copy.unknowns = thisUnknowns.map((unknown) => { return copyAttrName(unknown); });
	if (thisIgnores) copy.ignores = thisIgnores.map((ignore) => { return copyAttrName(ignore); });

	function isEmpty(obj) {
		for (const n in obj) {
			return false;
		}
		return true;
	}
	// remove empty entries
	for (const n in copy) {
		if (isEmpty(copy[n])) {
			delete copy[n];
		}
	}
	return copy;
}

function makeArrayTwoDimensional(arr) {
	arr = Array.isArray(arr) ? arr : [arr];
	arr = isTwoDimensionArray(arr) ? arr : [arr];
	return arr;
}

function isTwoDimensionArray(arr) {
	return arr.filter(Array.isArray).length > 0;
}

Attributes.Keys = attrKeys;

module.exports = Attributes;

/**
 * Standalone script that computes some datapoints to estimate the memory consumption of the RolesCache in regards to different parameters.
 * The data can be used to find a formula, e.g. via multiple linear regression. An interaction term between #Users and #Roles (x1*x2) is important
 * to include in such a regression as the number of role name strings that are stored is directly dependent on this product and poses the majority of
 * consumed memory of the cache.
 */

if (!global.gc) {
    console.error("This script requires --expose-gc flag enabled.");
    process.exit();
}

const fs = require('fs');
const { v4: uuidv4 } = require('uuid');
const RolesCache = require("./RolesCache");

const OUTPUT_FILE_PATH = "rolesCacheSizingGuide.csv";
const MAX_USERS = 1E5;
const MAX_ROLES = 1000;
const USERS_COUNT_FACTOR = 5;
const ROLES_COUNT_FACTOR = 10;

let lastMemoryUsage;
fs.writeFileSync(OUTPUT_FILE_PATH, "Users\tRoles\tUsers*Roles\tHeapUsed(Byte)\tCacheSize(Byte)\n", err => { });

let cache;
for (let rolesCount = 1; rolesCount <= MAX_ROLES; rolesCount *= ROLES_COUNT_FACTOR) {
    for (let userCount = 1; userCount <= MAX_USERS; userCount *= USERS_COUNT_FACTOR) {
        console.log(`Users: ${userCount}/${MAX_USERS} | Roles: ${rolesCount}/${MAX_ROLES}`);
        cache = new RolesCache(RolesCache.DEFAULT_TTL, Number.MAX_SAFE_INTEGER);

        global.gc(); // garbage-collector
        lastMemoryUsage = getCurrentMemoryUsage();
        for (let i = 0; i < userCount; i++) {
            const roles = [];
            for (let i = 0; i < rolesCount; i++) {
                roles.push(`some_role_${i}`);
            }

            cache.set(uuidv4(), roles);
        }

        appendToCSV({
            userCount,
            rolesCount,
            "userCount*rolesCount": userCount * rolesCount,
            heapUsed: getCurrentMemoryUsage() - lastMemoryUsage,
            objectMemory: roughSizeOfObject(cache)
        }, OUTPUT_FILE_PATH)
    }
}

console.log(`Done. Output written to ${OUTPUT_FILE_PATH}`);

// subject to distortions by garbage collector
function getCurrentMemoryUsage() {
    return process.memoryUsage().heapUsed;
}

function roughSizeOfObject(object) {
    const visited = []; // prevent circular references to cause infinite loop
    const stack = [object]; // working queue
    let bytes = 0;

    while (stack.length) {
        const value = stack.pop();

        if (typeof value === 'boolean') {
            bytes += 4;
        }
        else if (typeof value === 'string') {
            bytes += value.length * 2;
        }
        else if (typeof value === 'number') {
            bytes += 8;
        }
        else if (typeof value === 'object' && visited.indexOf(value) === -1) {
            visited.push(value);

            for (const i in value) {
                stack.push(value[i]);
                bytes += 4; // estimated memory of reference pointer to object
            }
        }
    }

    return bytes;
}

function appendToCSV(obj, filePath) {
    // Convert data to CSV format
    const csvData = Object.values(obj).join('\t') + '\n';

    // Append data to the CSV file
    fs.appendFileSync(filePath, csvData, (err) => {
        if (err) {
            console.error('Error appending to CSV file:', err);
        } else {
            console.log('Data appended to CSV file successfully!');
        }
    });
}
class RolesCache {
	ttl;
	limit;

	/** default TTL (time-to-live) in ms.*/
	static get DEFAULT_TTL() {
		return 1 * 60 * 1000;
	}

	static get DEFAULT_LIMIT() {
		return 10000;
	}

	constructor(ttl = RolesCache.DEFAULT_TTL, limit = RolesCache.DEFAULT_LIMIT) {
		this.ttl = ttl;
		this.limit = limit;
		this.clear();
		this.keys = [];
	}

	set(key, value) {
		if (this.limit > 0 && this.keys.length >= this.limit) {
			this.delete(this.keys[0]);
		}

		this.cache[key] = {
			value,
			expiry: Date.now() + this.ttl,
		};
		this.keys.push(key);
	}

	get(key) {
		const item = this.cache[key];

		if (!item) {
			return null;
		}

		if (item.expiry < Date.now()) {
			// deleting item from random index can be costly, so we avoid deletion here and only delete the oldest item (which is fast) when inserting into a full cache
			return null;
		}

		return item.value;
	}

	delete(key) {
		delete this.cache[key];
		const keyIndex = this.keys.findIndex(k => k === key);
		if(keyIndex >= 0) {
			this.keys.splice(keyIndex, 1);
		}
	}

	clear() {
		this.cache = Object.create(null);
	}

	entries() {
		return Object.entries(this.cache);
	}
}

module.exports = RolesCache;
const path = require("node:path");;
const xsenv = require('@sap/xsenv');

const { CredentialsConfigurationError } = require("./errors/errorTypes.js");
const Attributes = require("./attributes");
const { EventEmitter } = require("node:events");
const DcnEngine = require("../src/xcode/dcn-engine/build/commonjs/authorizationmanager.js").default;
const { emulateOPA } = require("../src/xcode/dcn-engine/build/commonjs/legacy/tranformer.js");
const BundleLoader = require("../src/xcode/dcn-engine/build/commonjs/bundle/bundleloader.js").default;
const LocalLoader = require("../src/xcode/dcn-engine/build/commonjs/bundle/localloader.js").default;

const VERSION = "dcn.opa.emulator:17.0.2";
const DEFAULT_DCL_PACKAGE = "dcr._default_";

/**
 * @typedef {import ("./bundle/BundleProvider.js")} BundleProvider
 */

class PolicyDecisionPoint extends EventEmitter {

	/**
	 * @type {DcnEngine}
	 */
	#dcnEngine = new DcnEngine();

	/**
	 * @type {BundleProvider}
	 */
	#bundleProvider;

	/**
	 * @type {PolicyDecisionPoint.HealthState}
	 */
	#healthState = PolicyDecisionPoint.HealthState.NOT_READY;
	
	/**
	 * Creates a new PolicyDecisionPoint instance that performs authorization checks based on the bundle provided by the given {@link BundleProvider}.
	 * @param {BundleProvider} [bundleProvider] a {@link BundleProvider} instance whose bundle will be used for authorization checks
	 */
	constructor(url, timeout=0, bundleProvider) {
		super();

		this.#bundleProvider = bundleProvider || this.#createBundleProvider();
		this.#bundleProvider.on("change", (bundleContent) => {
			this.#dcnEngine.updateBundle(bundleContent);
			this.#healthState = PolicyDecisionPoint.HealthState.OK;
		});
		this.#bundleProvider.on("requestFailed", (error) => {
			if(this.#healthState === PolicyDecisionPoint.HealthState.OK) {
				this.#healthState = PolicyDecisionPoint.HealthState.UPDATE_FAILED;
			} else {
				// keep NOT_READY state
			}
		});

		this.#bundleProvider.start();
	}

	#createBundleProvider() {
		if(process.env.AMS_DCN_ROOT) {
			return new LocalLoader(process.env.AMS_DCN_ROOT);
		} else {
			const credentials = this.#readCredentials();

			const bundleUrl = new URL(credentials.authorization_bundle_url);
			bundleUrl.pathname = path.join(bundleUrl.pathname, `${credentials.authorization_instance_id}.dcn.tar.gz`);

			return new BundleLoader(
				bundleUrl,
				credentials.authorization_instance_id,
				credentials.certificate,
				credentials.key);
		}
	}

	/**
	 * Uses the official @sap/xsenv library to find identity service credentials from the service bindings, e.g. when running on CF or K8s.
	 * Identity service bindings are identified based on their name, label or one of their tags being "identity".
	 * This behaviour is in line with the OPA buildpack.
	 * @returns {object} the credentials from the first identity service binding
	 * @throws {Error} if no identity service binding is found or more than one identity service binding is found
	 */
	#readCredentials() {
		const bindings = xsenv.filterServices( s => [s.name, s.label, ...(s.tags || [])].includes("identity") );
		
		if(bindings.length < 1) {
			throw new CredentialsConfigurationError("No authorization bundle could be found. Provide either a local DCN bundle via environment variable AMS_DCN_ROOT or run the application bound to an Identity Service on CF/K8S.");
		} else if (bindings.length > 1) {
			throw new CredentialsConfigurationError(`Expected only one SAP identity service binding but found ${bindings.length}.`);
		}

		return bindings[0].credentials;
	}

	/**
	 * Checks if access can be granted.
	 * Ignore elements are removed as if they where not present in the DCL rules.
	 * Note: if ignore values are set the endpoint is changed from METHOD_ALLOW to
	 * METHOD_ALLOW_PARTIAL to be able to process ignore values, this will also
	 * lead to a performance decrease
	 * @param {Attributes} attr
	 * @param {String} dclPackage
	 * @throws {Error} if no attributes are specified
	 * @return {Promise<boolean>} result as boolean
	 */
	async allow(attr) {
		if (!attr) {
			throw new Error("No attributes specified in pdp allow request");
		}
		const unknowns = attr.getUnknowns().map(attrName => attrName.getSegments());
		const ignores = attr.getIgnores().map(attrName => attrName.getSegments());

		const input = {
			$app: attr.getApp(),
			$env: attr.getEnv()
		};
		const dcl = attr.getDcl();

		const decision = await this.#dcnEngine.__internal_genericInquiry(dcl, unknowns, ignores, input);

		const result = decision.isGranted();

		const attributesJSON = attr.getJSON(); // attr.getJSON();
		const tokenClientId = attr.getTokenInfo()?.getClientId() ?? null;

		this.emit("allow", {
			"operation": "allow", // Name of the event
			"result": result, // response from pdp
			"attributesJSON": attributesJSON, // attributes sent to the pdp if any
			"dclPackage": DEFAULT_DCL_PACKAGE, // set DCL package
			"isSucceeded": true, // boolean - false if an error has occurred
			"tokenClientId": tokenClientId
		});
		this.emit("pdpEvaluation", {
			"operation": "allow", // Name of the event
			"result": result, // response from pdp
			"attributesJSON": attributesJSON, // attributes sent to the pdp if any
			"dclPackage": DEFAULT_DCL_PACKAGE, // set DCL package
			"isSucceeded": true, // boolean - false if an error has occurred
			"tokenClientId": tokenClientId
		});
		this.emit("amsPolicyEvaluation", {
			"operation": "allow", // Name of the event
			"result": result, // response from pdp
			"attributesJSON": attributesJSON, // attributes sent to the pdp if any
			"dclPackage": DEFAULT_DCL_PACKAGE, // set DCL package
			"isSucceeded": true, // boolean - false if an error has occurred
			"tokenClientId": tokenClientId
		});
		return result;
	}


	/**
	 * Computes the FilterClause.
	 * The unknown Attributes determine which elements should be in the filter clause.
	 * Ignore elements are removed as if they where not present in the DCL rules.
	 * @param {Attributes} attributes
	 * @param {String} dclPackage
	 * @throws {Error} if no attributes are specified
	 * @return {Promise} {condition: "", unknowns: "", ignores: ""} 
	 */
	async allowFilterClause(attr) {

		if (!attr) {
			throw new Error("No attributes specified in pdp allowFilter request");
		}

		const unknowns = attr.getUnknowns().map(attrName => attrName.getSegments());
		const ignores = attr.getIgnores().map(attrName => attrName.getSegments());

		const input = {
			$app: attr.getApp(),
			$env: attr.getEnv()
		};
		const dcl = attr.getDcl();

		const decision = await this.#dcnEngine.__internal_genericInquiry(dcl, unknowns, ignores, input);

		const opaResult = emulateOPA(decision);

		const attributesJSON = {}; // attr.getJSON();
		const tokenClientId = attr.getTokenInfo()?.getClientId() ?? null;
		this.emit("allowPartial", {
			"operation": "allowPartial", // Name of the event
			"result": opaResult, // response from pdp
			"attributesJSON": attributesJSON, // attributes sent to the pdp if any
			"dclPackage": DEFAULT_DCL_PACKAGE, // set DCL package
			"isSucceeded": true, // boolean - false if an error has occurred
			"tokenClientId": tokenClientId
		});
		this.emit("pdpEvaluation", {
			"operation": "allowPartial", // Name of the event
			"result": opaResult, // response from pdp
			"attributesJSON": attributesJSON, // attributes sent to the pdp if any
			"dclPackage": DEFAULT_DCL_PACKAGE, // set DCL package
			"isSucceeded": true, // boolean - false if an error has occurred
			"tokenClientId": tokenClientId
		});
		this.emit("amsPolicyEvaluation", {
			"operation": "allowPartial", // Name of the event
			"result": opaResult, // response from pdp
			"attributesJSON": attributesJSON, // attributes sent to the pdp if any
			"dclPackage": DEFAULT_DCL_PACKAGE, // set DCL package
			"isSucceeded": true, // boolean - false if an error has occurred
			"tokenClientId": tokenClientId
		});
		return {
			"condition": opaResult,
			"unknowns": attr.getUnknowns().map((attrName) => { return attrName.toString(); }),
			"ignores": attr.getIgnores().map((attrName) => { return attrName.toString(); })
		};
	}

	/**
	 * Tests for connectivity to the runtime.
	 * This method does not throw any.
	 * If the reason for a failure needs to be known use ping with
	 * the required DCL package of your application.
	 * @return {bool}
	 */
	async isReachable() {
		const result = this.#dcnEngine.isReady();
		this.emit("ping", {
			"operation": "ping", // Name of the event
			"result": result, // response from pdp
			"attributesJSON": {}, // attributes sent to the pdp if any
			"dclPackage": DEFAULT_DCL_PACKAGE, // set DCL package
			"isSucceeded": result, // boolean - false if an error has occurred
			"tokenClientId": null
		});
		this.emit("pdpEvaluation", {
			"operation": "ping", // Name of the event
			"result": result, // response from pdp
			"attributesJSON": {}, // attributes sent to the pdp if any
			"dclPackage": DEFAULT_DCL_PACKAGE, // set DCL package
			"isSucceeded": result, // boolean - false if an error has occurred
			"tokenClientId": null
		});
		return result;
	}

	/**
	 * Determine health state
	 * see: https://github.wdf.sap.corp/CPSecurity/cas-opa-sap#bundle-status-endpoint
	 * @return {Promise<PolicyDecisionPoint.HealthState>}
	 */
	async getHealthStatus() {
		this.emit("getStatus", {
			"operation": "getStatus", // Name of the event
			"result": this.#healthState, // response from pdp
			"attributesJSON": {}, // attributes sent to the pdp if any
			"dclPackage": DEFAULT_DCL_PACKAGE, // set DCL package
			"isSucceeded": this.#healthState, // boolean - false if an error has occurred
			"tokenClientId": null
		});
		this.emit("pdpEvaluation", {
			"operation": "getStatus", // Name of the event
			"result": this.#healthState, // response from pdp
			"attributesJSON": {}, // attributes sent to the pdp if any
			"dclPackage": DEFAULT_DCL_PACKAGE, // set DCL package
			"isSucceeded": this.#healthState, // boolean - false if an error has occurred
			"tokenClientId": null
		});

		return this.#healthState;
	}

	/**
	 * resolves when pdp is healthy
	 * @param {number} timeout in milliseconds
	 * @param {boolean} failOnStartupCheck throws error if not HealthState.OK
	 * @return {Promie<PolicyDecisionPoint.HealthState>}
	*/
	async startupCheck(timeout, failOnStartupCheck = true) {
		return new Promise((resolve, reject) => {
			const onTimeout = () => {
				const healthState = this.getHealthStatus();
				if (failOnStartupCheck) {
					reject(new Error(
						`AMS Bundle download failed, total wait time ${timeout} reached, state: ${healthState}`
					));
				} else {
					resolve(healthState);
				}
			};

			setTimeout(onTimeout, timeout);
			this.#dcnEngine.whenReady().then(() => resolve(PolicyDecisionPoint.HealthState.OK));
		});
	}

	/**
	 * Tests for existence of the dclPackage (default if not provided) and
	 * implicitly checks the connectivity to the runtime.
	 * @param {String} dclPackage
	 * @param {number} timeout defines the connection timeout (ms) to pdp: 0 indicates no timeout
	 * @throws {DCLPackageNameError} if package is not qualified
	 * @throws {OpaConnError} if opa is not reachable
	 * @throws {DCLError} if opa does not return true
	 * @return {Promise<Boolean>} true if ping was successful
	 */
	async ping(dclPackage = DEFAULT_DCL_PACKAGE) {

		const result = this.#dcnEngine.isReady();
		this.emit("ping", {
			"operation": "ping", // Name of the event
			"result": result, // response from pdp
			"attributesJSON": {}, // attributes sent to the pdp if any
			"dclPackage": dclPackage, // set DCL package
			"isSucceeded": result, // boolean - false if an error has occurred
			"tokenClientId": null
		});
		this.emit("pdpEvaluation", {
			"operation": "ping", // Name of the event
			"result": result, // response from pdp
			"attributesJSON": {}, // attributes sent to the pdp if any
			"dclPackage": dclPackage, // set DCL package
			"isSucceeded": result, // boolean - false if an error has occurred
			"tokenClientId": null
		});
		if (result === true) {
			return true;
		}
		throw new Error(`Opa responded with: for ping on package: "${dclPackage}"`, 400);
	}

	/**
	 * The format is not guaranteed.
	 * @return {String} version string
	 */
	async getVersion() {
		this.emit("getVersion", {
			"operation": "getVersion", // Name of the event
			"result": {
				"labels": {
					"version": VERSION
				}
			}, // response from pdp
			"attributesJSON": {}, // attributes sent to the pdp if any
			"dclPackage": null, // set DCL package
			"isSucceeded": true, // boolean - false if an error has occurred
			"tokenClientId": null
		});
		this.emit("pdpEvaluation", {
			"operation": "getVersion", // Name of the event
			"result": {
				"labels": {
					"version": VERSION
				}
			}, // response from pdp
			"attributesJSON": {}, // attributes sent to the pdp if any
			"dclPackage": null, // set DCL package
			"isSucceeded": true, // boolean - false if an error has occurred
			"tokenClientId": null
		});
		return VERSION;
	}
}

PolicyDecisionPoint.HealthState = {
	OK: "ok",
	UNREACHABLE: "unreachable",
	FATAL: "fatal",
	UPDATE_FAILED: "update_failed",
	NOT_READY: "not_ready"
};

module.exports = PolicyDecisionPoint;

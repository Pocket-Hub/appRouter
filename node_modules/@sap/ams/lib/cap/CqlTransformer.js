const AttributeName = require("../attributeName");
const Call = require("../call");

const TYPE_TO_BINARY_OPERATOR_MAP = {
    [Call.types.LT]: "<",
    [Call.types.LE]: "<=",
    [Call.types.EQ]: "=",
    [Call.types.NE]: "<>",
    [Call.types.GE]: ">=",
    [Call.types.GT]: ">",
    [Call.types.LIKE]: "LIKE"
};

class CqlTransformer {
    amsEntity;

    constructor(amsEntity) {
        this.amsEntity = amsEntity;
    }

    apply(item) {
        if (AttributeName.isAttributeName(item)) {
            return this.transformAttributeName(item);
        } else if (Call.isCall(item)) {
            return CqlTransformer.transformCall(item);
        }
    }

    transformAttributeName(name) {
        const segments = name.getSegments();
        if (segments[0] !== "$app") {
            return name.toString();
        }

        if (this.amsEntity.alias[0] === segments[1] && this.amsEntity.alias[1] === segments[2]) {
            const attribute = this.amsEntity.attributes.find(a => segments[3] === a.alias[a.alias.length - 1]);

            if (attribute !== undefined) {
                return attribute.name.slice(2).join(".");
            }
            
        }

        throw new Error("An invalid field reference found, it cannot be mapped back to CAP model: " + name.toString());
    }

    static transformCall(call) {
        const type = call.getType();

        if (Object.keys(TYPE_TO_BINARY_OPERATOR_MAP).includes(type)) {
            return CqlTransformer.transformBinaryOperation(call);
        }

        if (type === Call.types.AND || type === Call.types.OR) {
            return CqlTransformer.transformBooleanOperation(call, type);
        }

        if (type === Call.types.IN || type === Call.types.NOT_IN) {
            return CqlTransformer.transformValueListOperation(call);
        }

        throw new Error(`Transformation of call type '${type}' is currently not supported.`);
    }
    /**
     * Transforms the given DCN Engine call with a binary operation to an array structure that serves as input for this transformer.
     * 
     * @param {*} call a call from an DCN Engine condition
     * @param {*} listOp Call.types.AND or Call.types.OR
     * @returns a structure such as such as [arg0, ' >= ', arg1]
     */
    static transformBinaryOperation(binOp) {
        const operator = TYPE_TO_BINARY_OPERATOR_MAP[binOp.getType()];
        const operand0 = binOp.getArgument(0);
        const operand1 = binOp.getArgument(1);

        return [
            '(',
            CqlTransformer.quoteIfNeeded(operand0),
            ` ${operator} `,
            CqlTransformer.quoteIfNeeded(operand1),
            ')'
        ];
    };

    /**
     * Transforms the given DCN Engine call with a boolean operation to an array structure that serves as input for this transformer.
     * 
     * @param {*} call a call from an DCN Engine condition
     * @param {*} listOp Call.types.AND or Call.types.OR
     * @returns a structure such as ['(', arg0, ' AND ', arg1, ' AND ', arg2, ')']
     */
    static transformBooleanOperation(call, boolOp) {
        return [
            "(",
            ...call.getArguments().flatMap((i, idx) => idx === 0 ? [i] : [` ${boolOp.toUpperCase()} `, i]),
            ")"
        ];
    }

    /**
     * Transforms the given DCN Engine call with a value list operation to an array structure that serves as input for this transformer.
     * 
     * @param {*} call a call from an DCN Engine condition
     * @param {*} listOp Call.types.IN or Call.types.NOT_IN
     * @returns a structure such as ['(', arg0, ' NOT IN ', arg1, ', ', arg2, ', ', arg3, ')']
     */
    static transformValueListOperation(call, listOp) {
        const operator = (listOp == Call.types.IN) ? " IN " : " NOT IN ";

        return [
            "(",
            call.getArgument(0),
            operator,
            ...call.getArguments().slice(1).flatMap((i, idx) => idx === 0 ? [i] : [", ", i]),
            ")"
        ];
    }

    static quoteIfNeeded(arg) {
        if (typeof arg === "string") {
            return `'${arg}'`
        } else {
            return arg;
        }
    }

    static createInstance(amsEntity) {
        const t = new CqlTransformer(amsEntity);

        return item => t.apply(item);
    }
}

module.exports = CqlTransformer;

const cds = require("@sap/cds");

const RolesCache = require("../roles/RolesCache");
const RolesProvider = require("../roles/RolesProvider");
const Principle = require("../Principle");
const config = require("./config/capAmsConfig");
const { CAP_PSEUDO_ROLES, CAP_USER_ROLE_ACTIVE } = require("./constants");

const LOG = cds.log("ams");

/**
 * CAP middleware that runs behind the 'auth' middleware for incoming requests to compute user roles based on AMS policies.
 * The resulting roles are added to the 'roles' property of the CAP user object.
 * To reduce latency of incoming requests, the computed roles of a user are cached.
 */
class RolesMiddleware {
    #cache;

    constructor(pdp) {
        const cacheTtl = config.cache?.TTL ?? RolesCache.DEFAULT_TTL;
        const cacheLimit = config.cache?.limit ?? RolesCache.DEFAULT_LIMIT;
        this.#cache = new RolesCache(cacheTtl, cacheLimit);
        this.rolesProvider = new RolesProvider(pdp).withRolesCache(this.#cache);
    }

    async handleRequest(req, res, next) {
        const user = cds.context?.user;
        if (!user) {
            LOG.debug("Skipping roles middleware because user is missing from cds.context.");
            return next();
        }

        if (user === cds.User.default
            || typeof cds.User.default === "function" && user instanceof cds.User.default) // in cds 7, User.default is a class, not a singleton
        {
            LOG.debug("Skipping roles middleware for default user.");
            return next();
        }

        LOG.debug("Roles middleware is processing request to append AMS user roles.");
        try {
            const amsRoles = await this.getRoles(user) || [];
            LOG.debug("User roles before AMS middleware:", user.roles);
            LOG.debug("AMS user roles:", amsRoles);
            RolesMiddleware.appendRoles(user, amsRoles);
            LOG.debug("Resulting user roles after AMS middleware:", user.roles);
        } catch (e) {
            LOG.warn("Could not determine AMS user roles: ", e);
        } finally {
            next();
        }
    }

    async getRoles(user) {
        const payload = user.tokenInfo?.getPayload?.();
        if (!payload || payload.app_tid == null || !payload.scim_id) {
            throw new Error("User object is missing payload with app_tid and scim_id which are required to identify policies assigned to the user.");
        }

        const { app_tid, scim_id } = payload;
        const principle = new Principle(app_tid, scim_id);

        let roles = await this.rolesProvider.getRoles(principle);
        const containedPseudoRoles = roles.filter(r => CAP_PSEUDO_ROLES.includes(r.toLowerCase()));

        if (containedPseudoRoles.length > 0) {
            LOG.warn(`The following CAP pseudo roles were attempted to be assigned via AMS policies: ${containedPseudoRoles}. This is not supported for security reasons.`);
            roles = roles.filter(r => !CAP_PSEUDO_ROLES.includes(r.toLowerCase()));
        }

        return roles;
    }

    toString() {
        return `AMS roles middleware [cache.TTL = ${this.#cache.ttl}]`;
    }

    /** Adds the given roles to the 'roles' property of the CAP user object. */
    static appendRoles(user, amsRoles) {
        user.roles = user.roles || {};
        amsRoles.forEach(role => {
            user.roles[role] = CAP_USER_ROLE_ACTIVE;
        });
    }
}

module.exports = RolesMiddleware;
const path = require("path");
const fs = require("fs/promises");

const cds = require("@sap/cds");

const env = require("./config/capAmsEnv");
const Attributes = require("../attributes");
const Call = require("../call");
const EntityMapper = require("./EntityMapper");
const CqlTransformer = require("./CqlTransformer");
const { RESTRICT_FILTER_ALL } = require("./constants");

const LOG = cds.log("ams");

/**
 * Computes effective restrictions of CAP service endpoints by merging in restrictions imposed by AMS policies.
 * To install the RestrictionsProvider for a CAP service, the the given CAP service needs to passed to the hookIntoService function.
 */
class RestrictionsProvider {
    #pdp;

    constructor(pdp) {
        this.#pdp = pdp;
        this.mapper = null;
    }

    /**
     * Overwrites the [getRestrictions](https://github.tools.sap/cap/cds/blob/main/libx/_runtime/common/generic/auth/restrictions.js) method on a service
     * with a wrapper that weaves in the restrictions imposed by AMS into the existing restrictions.
     *  
     * @param service a cds service instance
     */
    hookIntoService(service) {
        LOG.debug(`Overriding getRestrictions of ${service.name}.`);

        const amsRestrictionsProvider = this;
        const super_getRestrictions = service.getRestrictions;

        /**
         * Wrapper method for original [getRestrictions](https://github.tools.sap/cap/cds/blob/main/libx/_runtime/common/generic/auth/restrictions.js) method of service.
         * After calling original implementation to collect original reestrictions, it computes a [CQL where clause](https://cap.cloud.sap/docs/guides/authorization#instance-based-auth).
         * It then combines the original restrictions with the restrictions imposed by AMS.
         * 
         * @returns {Promise<Array>} Promise that resolves with:
         * - [] (no access), if original restrictions denied access or AMS denied access unconditionally
         * - {grant: \<event\>, where: \<cql\>} if AMS restrictions are the only restrictions to apply
         * - original restrictions with \<cql\> appended with logical AND to where property of each existing restriction
         */
        service.getRestrictions = async function (definition, event, user) {
            LOG.debug(`AMS implementation of getRestrictions called for ${event} on ${definition.name}.`);
            let restrictions = null;
            if (super_getRestrictions) {
                restrictions = await super_getRestrictions.call(service, definition, event, user);
            }

            LOG.debug("(Non-AMS) restrictions returned by original getRestrictions implementation:", RestrictionsProvider.formatRestrictions(restrictions));

            if (Array.isArray(restrictions) && restrictions.length === 0) {
                // access already denied before AMS
                restrictions = RESTRICT_FILTER_ALL;
            } else {
                let cql;
                try {
                    cql = await amsRestrictionsProvider.getAmsRestrictions(event, definition.name, user);
                } catch (e) {
                    LOG.error(`Could not compute restrictions for ${event} on ${definition.name}.`, e);
                    throw e;
                }

                if (cql === false) {
                    LOG.debug("CQL is unconditionally false. Filtering away all entities.");
                    restrictions = RESTRICT_FILTER_ALL;
                } else if (cql === true) {
                    LOG.debug("CQL is unconditionally true. Keeping original restrictions.");
                } else if (cql) {
                    LOG.debug("Merging CQL into original restrictions.");
                    restrictions = RestrictionsProvider.mergeRestrictions(event, restrictions, cql);
                }
            }

            LOG.debug("Resulting restrictions:", RestrictionsProvider.formatRestrictions(restrictions));
            return restrictions;
        };
    }

    /**
     * Determines AMS access restrictions in form of a CQL condition that CAP needs to evaluate before authorizing the action on the given CAP entity.
     *
     * @param action CAP action, e.g. "READ"
     * @param capEntity CAP entity segments, e.g. ["CatalogService", "Book"]
     * @param user req.user object
     * @returns a CQL string to use as WHERE condition in CAP or null if no further restrictions are imposed via AMS
     */
    async getAmsRestrictions(action, capEntity, user) {
        if (!this.mapper) {
            await this.initEntityMapper();
        }

        const amsEntity = this.mapper.capToAms(capEntity);
        if (!amsEntity) {
            LOG.debug(`No AMS mapping found for CAP entity ${capEntity}. Skipping AMS restriction check.`)
            return null;
        }

        const unknowns = amsEntity.attributes.map(a => ["$app", ...a.alias]);
        if (unknowns.length === 0) {
            // it makes no sense to ask the DCN Engine
            return true;
        }

        const payload = user.tokenInfo?.getPayload();
        if (!payload || payload.app_tid == null || !payload.scim_id) {
            throw new Error("User object is missing payload with app_tid and scim_id which are required to identify policies assigned to the user.");
        }

        const { app_tid, scim_id } = payload;
        const resource = amsEntity.alias.join(".");

        const attributes = new Attributes()
            .setResource(resource)
            .setAction(action)
            .setUnknowns(unknowns)
            .setPrincipalToPolicies([app_tid, scim_id])
            .setTenant(app_tid);

        const amsEventService = await env.getAmsEventService();
        await amsEventService.sendGetRestrictions(action, capEntity, user, attributes);

        try {
            const filterClause = await this.#pdp.allowFilterClause(attributes);
            const condition = filterClause.condition;

            if (typeof condition === "boolean") {
                return condition;
            } else {
                LOG.debug("DCN Engine returned filter clause with condition:", condition);

                const call = Call.fromCondition(condition);
                const cqlString = Call.transform(call, CqlTransformer.createInstance(amsEntity));

                LOG.debug("DCN Engine condition as CQL:", cqlString);
                return cqlString;

                // TODO ??? Take into account $user and $env placeholders that can be in the returned condition
                // ??? Such identifier decoding: `$app.catService.catServiceBooks.ams_title`
                // ??? If starts with `$app.` then goes service dcl-name then - entity dcl-name then property dcl-name.
            }
        } catch (err) {
            throw new Error("Error while getting or parsing filter clause from DCN Engine.", { cause: err }, 500);
        }
    }

    /** 
     * Merges the given cql condition into the existing restrictions and returns the resultings restrictions.
     * If no restrictions are given, returns exactly one restriction with the given cql as 'where' condition.
     * Otherwise, adds the given condition to the 'where' condition of the existing restrictions by concatenating with logical 'AND'.
     * 
     * @param {Array} restrictions an array of CAP restrictions
     */
    static mergeRestrictions(event, restrictions, cql) {
        if (restrictions == null || restrictions.length < 1) {
            return [{
                grant: event,
                where: cql
            }];
        } else {
            for (const r of restrictions) {
                if (!r.where) {
                    r.where = cql;
                } else {
                    // build logical conjunction of existing CQL and to be inserted CQL
                    r.where = `(${r.where}) AND (${cql})`;
                }
            }

            return restrictions;
        }
    }

    /** Initializes the entity mapper by reading in the entity mapping file. */
    async initEntityMapper() {
        const dclPath = env.getPathToDcl();
        const entityMappingPath = path.join(dclPath, "entityMapping");

        try {
            const entityMappingJson = await fs.readFile(entityMappingPath, "utf-8");
            const entityMapping = JSON.parse(entityMappingJson);
            this.mapper = new EntityMapper(entityMapping);
            LOG.debug(`Loaded cds2dcl entity mapping from ${entityMappingPath}.`);
        } catch (e) {
            LOG.error(`Could not load cds2dcl entity mapping from ${entityMappingPath}.`, e);
            throw e;
        }
    }

    /** Formats the given CAP restrictions for logging by masking away the 'target' property which is a very deep structure. */
    static formatRestrictions(restrictions) {
        if (!Array.isArray(restrictions)) {
            return String(restrictions);
        }

        return restrictions.map(r => ({
            ...r,
            "target": "<target>"
        }));
    }
}

module.exports = RestrictionsProvider;

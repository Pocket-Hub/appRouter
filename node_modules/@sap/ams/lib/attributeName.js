/* eslint-disable no-useless-escape */
 
"use strict";

const attrKey = require("./attributeKeys");

/*
* Basically just an array of strings
* But we can not use point separated strings instead because every character is
* allowed even '.' -> points can not be use as separator
*/
function AttributeName(other) {
	this._isAttributeName = true;
	this.segments = [];

	// copy constructor
	if (AttributeName.isAttributeName(other)) {
		this.segments = other.getSegments().slice(); // slice to create copy
	} 
}

/**
 * Creates a new AttributeName object from the provided array
 * @param {Array} array 
 * @returns new AttributeNames with array items as segments
 */
AttributeName.fromArray = function(array) {
	const segments = Array.isArray(array) ? array : [array];
	return new AttributeName().set(segments);
};

/**
 * Creates a new AttributeName object from the provided string
 * @param {String} str 
 * @returns new AttributeNames with segments extracted from the string
 */
AttributeName.fromString = function(str) {
	return AttributeName.fromArray(stringToSegments(str));
};

AttributeName.prototype.getFirstSegment = function () {
	return this.segments[0];
};

AttributeName.prototype.getSegments = function() {
	return this.segments;
};

/**
 * @param {int} index starting with zero
 * @returns string content of segment
 */
AttributeName.prototype.getSegment = function(index) {
	return this.segments[index];
};

AttributeName.prototype.size = function() {
	return this.segments.length;
};

AttributeName.prototype.isEmpty = function() {
	return this.segments.length == 0;
};

// adds one segment to the AttributeName
AttributeName.prototype.add = function(segment) {
	this.segments.push(segment);
	return this;
};

// sets all segments of the AttributeName
AttributeName.prototype.set = function(segments) {
	this.segments = segments;
	return this;
};

/**
 * @return {String} returns a String representation separated by dots
 */
AttributeName.prototype.toString = function() {
	// quote segments containing '.'
	const tmpSegments = this.segments.map(segment => {
		if (segment.includes(".")) segment = `"${segment}"`;
		return segment;
	});
	return tmpSegments.join(".");
};

/**
 * @return {String} returns an encoded String representation
 */
AttributeName.prototype.toOpaInputName = function() {
	return AttributeName.toOpaInputName(this);
};

/**
 * To verify if an object is of type AttributeName
 */
AttributeName.isAttributeName = function(obj) {
	return obj && (obj instanceof AttributeName || Boolean(obj._isAttributeName));
};

// Algorithm copied from AMS Java Lib:
// https://github.wdf.sap.corp/CPSecurity/cas-dcl-ide/blob/master/rt.parent/rt.opa/src/main/java/com/sap/cloud/security/ams/dcl/rt/opa/OpaTools.java#L76-L109
/**
 * Takes as argument an AttributeName and creates a opaInputString
 * This function is used internally in the policyDecisionPoint
 * @param {String} attrName is the attributeName in string form eg. ($dcl.resource)
 * @return {String} returns an encoded String representation eg. "input[\"$dcl\"][\resource\"]",
 * this is necessary for the post request to the opa
 */
AttributeName.toOpaInputName = function(attrName) {
	const INPUT_KEY = "input";
	let opaInputName = "";

	if (!attrName) {
		throw new Error("AttributeName parameter must be defined");
	}
	if (!AttributeName.isAttributeName(attrName)) {
		throw new Error("Input parameter must be of type AttributeName");
	}
	if (attrName.isEmpty()) {
		return INPUT_KEY;
	}
	opaInputName += INPUT_KEY;

	for (let j = 0; j < attrName.size(); ++j) {
		const id = attrName.getSegment(j);
		opaInputName += "[\"";
		if (id.includes("\\") || id.includes("\"")) {
			for (let i = 0; i < id.length; ++i) {
				const ch = id.charAt(i);
				if (ch == "\\") {
					opaInputName += "\\\\";
				} else if (ch == "\"") {
					opaInputName += "\\\"";
				} else {
					opaInputName += ch;
				}
			}
		} else {
			opaInputName += id;
		}
		opaInputName += "\"]";
	}

	return opaInputName;
};


/**
 * transforms string to AttributeName segments
 * "author.created" -> ["author", "created"]
 * @param {String} str 
 */
function stringToSegments(str) {
	// pre checks
	// empty segments like '..' pr '""' are not allowed
	const emptySegmentRegex =  /\.\.|""/g;
	if (str.match(emptySegmentRegex)) throw("no empty segments allowed");
	// 'bla."abc"abc' second abc should not be matched
	// 'abc"abc"' first abc should not be matched
	// false input if before and after a single double quote are characters not of type '.' or '\'
	const quoteError = /[^\.\\]"[^\.\\]/g;
	if (str.match(quoteError)) throw("segments must start with '.' or '\"'");

	/**
	 * "(?:\\.|[^"\\])*"   # capture inside of double quotes but allow \ and \" inside
	 * |                   # orâ€¦
	 * [^\.]+              # everything that is not dot -> unlimited times
	 */
	const splitSegmentsRegex = /"(?:\\.|[^"\\])*"|[^\.]+/g;
	let segments = str.match(splitSegmentsRegex);
	if (!segments) throw("no segment found in input string");

	// post checks
	segments = segments.map((segment) => {
		// quoted segment
		if (segment.charAt(0) === '"' && segment.charAt(segment.length-1) === '"') {
			// quotes defining fragments are not removed by splitSegmentsRegex -> delete beginning and ending quotes
			segment = segment.slice(1, -1);
		} else { // not quoted segment
			// 'abc."abc' should not be allowed because " is not inside of double quote
			const hasSingleQuoteRegex = /^(?!\\)"|[^\\]".?/g;
			if (segment.match(hasSingleQuoteRegex)) throw("string not terminated by \"");
		}
		// remove escape character before quotes in quoted segments
		segment = segment.replace(/\\"/g, '"');
		return segment;
	});

	const firstSegment = segments[0];
	const topLevelSegments = [ attrKey.DCL_SECTION, attrKey.APP_SECTION, attrKey.ENV_SECTION ];
	// automatically adjust first segment for $app or $user if it's not $dcl, $app or $env
	if (topLevelSegments.indexOf(firstSegment) === -1) {
		if (firstSegment.startsWith("$")) {
			segments = [attrKey.ENV_SECTION, ...segments];
		} else {
			segments = [attrKey.APP_SECTION, ...segments];
		}
	}
	return segments;
}

AttributeName.common = {
	// APP section
	APP: AttributeName.fromString(attrKey.APP_SECTION),
	// ENV section
	ENV: AttributeName.fromString(attrKey.ENV_SECTION),
	ENV_USER: AttributeName.fromString(attrKey.ENV_SECTION).add(attrKey.ENV_USER),
	ENV_USER_USER_UUID: AttributeName.fromString(attrKey.ENV_SECTION).add(attrKey.ENV_USER_USER_UUID),
	ENV_USER_EMAIL: AttributeName.fromString(attrKey.ENV_SECTION).add(attrKey.ENV_USER_EMAIL),
	ENV_USER_GROUPS: AttributeName.fromString(attrKey.ENV_SECTION).add(attrKey.ENV_USER_GROUPS),
	// DCL section
	DCL: AttributeName.fromString(attrKey.DCL_SECTION),
	DCL_ACTION: AttributeName.fromString(attrKey.DCL_SECTION).add(attrKey.DCL_ACTION),
	DCL_RESOURCE: AttributeName.fromString(attrKey.DCL_SECTION).add(attrKey.DCL_RESOURCE),
	DCL_TENANT: AttributeName.fromString(attrKey.DCL_SECTION).add(attrKey.DCL_TENANT),
	DCL_POLICIES: AttributeName.fromString(attrKey.DCL_SECTION).add(attrKey.DCL_POLICIES),
	DCL_SCOPE_FILTER: AttributeName.fromString(attrKey.DCL_SECTION).add(attrKey.DCL_SCOPE_FILTER),
	DCL_PRINCIPAL_TO_POLICIES: AttributeName.fromString(attrKey.DCL_SECTION).add(attrKey.DCL_PRINCIPAL_TO_POLICIES)
};

module.exports = AttributeName;


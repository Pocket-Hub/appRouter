"use strict";

const AttributeName = require("./attributeName");

/**
 * wraps a allowFilterClause condition and simplifies working with it
 */
function Call() {
	this._isCall = true;
	let type;
	let args = []; // array of Call objects

	this.setType = function(t) {
		if(Object.values(Call.types).includes(t)) {
			type = t;
			return this;
		}
		throw `Could not set Call type for unsupported type: "${t}"`;
	};

	this.getType = function() {
		return type;
	};

	this.addArgument = function(arg) {
		args.push(arg);
		return this;
	};

	this.setArguments = function(arg) {
		args = Array.isArray(arg) ? arg : [arg];
		return this;
	};

	this.getArguments = function() {
		return args;
	};

	this.getArgument = function(index) {
		return args[index];
	};

	this.getArgumentCount = function() {
		return args.length;
	};
}

Call.types = {
	AND:         "and",
	OR:          "or",
	IS_NULL:     "is_null",
	IS_NOT_NULL: "is_not_null",
	LIKE:        "like",
	NOT_LIKE:    "not_like",
	IN:          "in",
	NOT_IN:      "not_in",
	LT:          "lt",
	LE:          "le",
	EQ:          "eq",
	NE:          "ne",
	GE:          "ge",
	GT:          "gt"
};

/**
 * To verify an object is of type Call
 */
Call.isCall = function(obj) {
	return obj instanceof Call || Boolean(obj._isCall);
};

/**
 * transforms the condition json to a call object
 * Note: While transforming to Call, AttributeNames object are created
 * @param {Object} condition the conditionJSON which is transformed to a Call
 * @throws error if condition is only boolean
 * @throws error if unexpected parsing error
 */
Call.fromCondition = function(condition) {
	if (typeof condition === "boolean") {
		throw "Expected object - given boolean - can not transform boolean to call";
	}
	const parsedCond = parseAttrNamesCond(condition);
	const callTree = [];
	walk(parsedCond);
	if (callTree.length != 1) {
		throw "Unexpected length of callTree - something went wrong";
	}
	return callTree[0].callObj;

	/**
	 * Iterates the condition tree
	 */
	function walk(tree) {
		for (const key in tree) {
			const args = tree[key];
			if (args && typeof args == "object" && !(AttributeName.isAttributeName(args))) {
				walk(args);
			} else {
				if (! Array.isArray(tree)) {
					if (isLeaf(tree)) {
						addToCallTree(tree);
					} else {
						callTree.push({
							"callObj": new Call().setType(tree.call),
							"numArgs": tree.args.length,
							"currArgs": 0
						});
					}
				}
			}
		}
	}

	/**
	 * checks if the call contains a attributeName
	 */
	function isLeaf(call) {
		return (call.args &&
			( AttributeName.isAttributeName(call.args[0]) || AttributeName.isAttributeName(call.args[1]) ));
	}

	/**
	 * creates call tree from bottom to Top in order to have only one
	 * call with all other calls linked as args
	 */
	function addToCallTree(callItem) {
		const newCall = new Call().setType(callItem.call).setArguments(callItem.args);

		if (callTree.length == 0) {
			callTree.push({ "callObj": newCall });
			return;
		}

		let lastTreeEntry = callTree[callTree.length-1];
		lastTreeEntry.callObj.addArgument(newCall);
		lastTreeEntry.currArgs++;

		while (callTree.length > 1 && lastTreeEntry.currArgs == lastTreeEntry.numArgs) {
			const last = callTree.pop();
			lastTreeEntry = callTree[callTree.length-1];
			lastTreeEntry.callObj.addArgument(last.callObj);
			lastTreeEntry.currArgs++;
		}
	}
};

/**
 * Transforms a Call into a String.
 * This function will be called recursively until strItems contains only strings
 * @param {Call} call the call which should be transformed to string
 * @param {func} transformItemFunc this function takes as argument a Call object
 * 		and returns either a plain string or an array which can contain strings and calls
 * @returns String
 */
Call.transform = function(call, transformItemFunc) {
	const strItems = Array.isArray(call) ? call : [call];
	if (!hasAttributeNameOrCall(strItems)) {
		return strItems.join("");
	}
	for (const idx in strItems) {
		const item = strItems[idx];
		if (AttributeName.isAttributeName(item) || Call.isCall(item)) {
			strItems.splice(idx, 1);
			return Call.transform(insert(strItems, idx, transformItemFunc(item)), transformItemFunc);
		}
	}

	function hasAttributeNameOrCall(strItems) {
		for (const item of strItems) {
			if (AttributeName.isAttributeName(item) || Call.isCall(item))
				return true;
		}
		return false;
	}

	function insert(arr, index, items) {
		return [
			...arr.slice(0, index),
			...items,
			...arr.slice(index)
		];
	}
};

/**
 * transforms raw AttributeName from DCN Engine:
 * {
 * 	  "ref": [
 *       "$dcl",
 *       "policies"
 *    ]
 * }
 * to:
 * "new AttributeName($dcl.policies);"
 * in a condition result
 */
function parseAttrNamesCond(condition) {
	// create copy
	const conditionCopy = JSON.parse(JSON.stringify(condition));
	transformObject(conditionCopy);
	return conditionCopy;

	function transformObject(tree) {
		for (const key in tree) {
			const args = tree[key];
			if (args?.ref) {
				// remove ref notation from tree and insert attributeName
				tree.splice(key, 1, AttributeName.fromArray(args.ref));
			}
			if (args && typeof args == "object")
				transformObject(args);
		}
	}
}

module.exports = Call;

"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getCompilerPath = exports.isJavaInstalled = exports.compileDcl = void 0;
const fs = __importStar(require("fs"));
const child_process_1 = require("child_process");
const yargs_1 = __importDefault(require("yargs"));
const path = __importStar(require("path"));
const util_1 = require("./util");
let logger = (0, util_1.getLogger)('error');
const compilerPath = path.join('..', 'resources', 'dcl-compiler', 'dcl.jar');
const jarOption = '--add-opens=java.base/java.lang=ALL-UNNAMED';
function compileDcl(args) {
    const options = (0, yargs_1.default)(args)
        .usage('Usage: compile-dcl --dcl [DCL_SRC_DIR] --rego [DCL_TARGET_DIR]')
        .options({
        d: { type: 'string', alias: 'dcl', describe: 'path to DCL source directory', demandOption: true },
        r: { type: 'string', alias: 'rego', describe: 'path to REGO target directory', demandOption: true },
        l: { type: 'string', alias: 'log-level', describe: 'log level', default: 'error', demandOption: false, choices: ['debug', 'info', 'warn', 'error', 'silent'] },
        f: { type: 'string', alias: 'failOn', describe: 'fail on error, deprecation or warning', default: 'error', choices: ['error', 'deprecation', 'warning'] }
    })
        .example('compile-dcl -d dcl-src/ -r rego/', 'compiles dcl in dir: dcl-src/ with destination dir rego/')
        .parseSync();
    logger = (0, util_1.getLogger)(options.l);
    const failOn = options.f;
    let regoPath = options.r;
    let dclPath = options.d;
    // adjust the path in case relative paths are used
    if (!path.isAbsolute(regoPath))
        regoPath = path.join(process.cwd(), regoPath);
    if (!path.isAbsolute(dclPath))
        dclPath = path.join(process.cwd(), dclPath);
    if (!isJavaInstalled() || !checkDirsExist(dclPath, regoPath)) {
        return 255;
    }
    const child = (0, child_process_1.spawnSync)('java', [
        jarOption,
        '-jar',
        compilerPath,
        `-out=${regoPath}`,
        `-failOn=${failOn}`,
        dclPath
    ], {
        cwd: __dirname
    });
    const stdout = child.stdout.toString();
    const stderr = child.stderr.toString();
    if (stdout)
        logger.info(`stdout:\n${stdout}`);
    if (stderr)
        logger.error(`stderr:\n${stderr}`);
    if (child.error || child.status != 0 || !dclTestSuccessful(regoPath)) {
        return 255;
    }
    return 0;
}
exports.compileDcl = compileDcl;
function checkDirsExist(src, target) {
    // Check dcl resources dir
    try {
        fs.accessSync(src);
    }
    catch (err) {
        logger.error(`DCL resource dir: ${src} does not exist.`);
        return false;
    }
    // Check dcl target dir
    try {
        fs.accessSync(target);
    }
    catch (err) {
        logger.info(`compile target dir: ${target} does not exist. creating it.`);
        fs.mkdirSync(target);
    }
    return true;
}
function isJavaInstalled() {
    const child = (0, child_process_1.spawnSync)('java', ['--version']);
    if (child.error || child.status != 0) {
        logger.error('Failed Java version check. Is Java installed?');
        return false;
    }
    return true;
}
exports.isJavaInstalled = isJavaInstalled;
function dclTestSuccessful(regoPath) {
    const opaPath = (0, util_1.getOpaPath)(); // might throw an error, but is catched on top level
    const child = (0, child_process_1.spawnSync)(opaPath, ['test', '-v', regoPath]);
    const stdout = child.stdout.toString();
    const stderr = child.stderr.toString();
    if (stdout || stderr)
        logger.info('DCL TESTS:');
    if (stdout)
        logger.info(`stdout: ${stdout}`);
    if (stderr)
        logger.error(`stderr: ${stderr}`);
    if (child.error || child.status != 0) {
        return false;
    }
    return true;
}
function getCompilerPath() {
    return compilerPath;
}
exports.getCompilerPath = getCompilerPath;
//# sourceMappingURL=compileDcl.js.map
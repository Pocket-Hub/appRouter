"use strict";
/* eslint-disable @typescript-eslint/no-var-requires */
const path = require('path');
const fs = require('fs');
const cds = require('@sap/cds');
const axios = require('axios');
const devEnv = require('./capAmsDevEnv');
const { convert: convertCds } = require('./cds2dcl');
const { compileDcl } = require('../compileDcl');
const { startOpa } = require('../startOpa');
const { stopOpa } = require('../stopOpa');
const { debouncePromise } = require('../util');
const LOG = cds.log('ams');
const DCL_ROOT_PACKAGE = 'cap';
const DCL_HEADER = '' +
    '// ----------------------------------------------------------------------------------\n' +
    '// Generated from a CAP model by the SAP AMS Dev Plugin (@sap/ams-dev)\n' +
    '// ----------------------------------------------------------------------------------\n' +
    '\n';
let opaConfigFilePath;
/**
 * Compiles the given CDS model to a set of DCL policies and an entity mapping file.
 * Uses the given write function to write the files, e.g. from a CAP BuildPlugin.
 * If no write function is given, writes to the application's default DCL folder path.
 */
async function compileCds(model, write = devEnv.createWriteFunction(devEnv.getPathToDclOutput())) {
    const { schema, basePolicies, _dcl_cap: entityMapping } = await convertCds(model);
    await Promise.all([
        write(DCL_HEADER + schema).to('schema.dcl'),
        write(entityMapping).to(cds.env?.['project-nature'] === 'java' ? path.join(cds.root, 'srv', 'src', 'main', 'resources', '_dcl_.cap') : 'entityMapping'),
        write(DCL_HEADER + basePolicies).to(path.join(DCL_ROOT_PACKAGE, 'basePolicies.dcl'))
    ]);
}
/**
 * Copies the custom DCL policies next to the policies compiled from the cds model.
 *
 * @param {function} write function for writing files relative to a target directory, e.g. from a CAP BuildPlugin. If no write function is given, writes to the application's default DCL folder path
 * @param {path} inputDir directory from which to recursively copy files. If no directory is given, copies from the custom DCL directory
 */
async function copyCustomPolicies(write = devEnv.createWriteFunction(devEnv.getPathToDclOutput()), inputDir = devEnv.pathToCustomDcl) {
    if (!fs.existsSync(inputDir)) {
        return;
    }
    const files = await fs.promises.readdir(inputDir);
    await Promise.all(files.map(async (file) => {
        const filePath = path.join(inputDir, file);
        if (fs.statSync(filePath).isDirectory()) {
            await copyCustomPolicies(write, filePath);
        }
        else {
            const content = await fs.promises.readFile(filePath);
            write(content).to(path.relative(devEnv.pathToCustomDcl, filePath));
        }
    }));
}
/** Removes the DCL folder and all its content. */
async function cleanDclOutput() {
    const dclFolder = devEnv.getPathToDclOutput();
    if (fs.existsSync(dclFolder)) {
        return fs.promises.rm(dclFolder, { recursive: true });
    }
}
/** Compiles the DCL files of the application to REGO as input for a local OPA instance. */
async function compileLocalDcl() {
    const args = [
        '-d', devEnv.getPathToDclOutput(),
        '-r', devEnv.pathToLocalRego
    ];
    try {
        compileDcl(args);
        LOG.debug('DCL compilation finished.');
    }
    catch (error) {
        LOG.error('DCL compilation failed.');
        LOG.error(error.stdout);
    }
}
/** Removes the REGO input for the local OPA instance. */
async function cleanLocalRego() {
    const regoFolder = devEnv.pathToLocalRego;
    if (fs.existsSync(regoFolder)) {
        return fs.promises.rm(regoFolder, { recursive: true });
    }
}
/** Writes the policy assignments to an input file for OPA. */
async function writePolicyAssignments(principal2policies) {
    const opaInputFolder = devEnv.pathToLocalOpaInput;
    if (!fs.existsSync(path.dirname(opaInputFolder))) {
        fs.mkdirSync(path.dirname(opaInputFolder), { recursive: true });
    }
    const write = devEnv.createWriteFunction(opaInputFolder);
    write({ principal2policies }).to(devEnv.policyAssignmentFilename); // wrapping is necessary for JSON root to begin with 'principal2policies'
}
/**
 * Starts a local OPA instance with the previously generated REGO and policy assignments files in watch mode.
 * Clears any previously set OPA configuration file, so that future calls to restartOpa will start it again with local input.
 */
function startOpaWithLocalInput() {
    const args = [
        '-r', devEnv.pathToLocalRego,
        '-u', `file:///${devEnv.pathToLocalAssignments}`,
        '-p', devEnv.localOpaPort,
        '-d', true,
        '-w', true
    ];
    return startOpa(args);
}
/** Starts a local OPA instance with a previously configured configuration file. */
function startOpaWithConfigFile() {
    if (!opaConfigFilePath)
        throw new Error('Missing OPA configuration file path.');
    const args = [
        '-r', '',
        '-c', opaConfigFilePath,
        '-p', devEnv.localOpaPort,
        '-d', true,
        '-w', false
    ];
    return startOpa(args);
}
/** Starts OPA with configuration file if it was previously set, otherwise with local input. */
async function startOpaByType() {
    return opaConfigFilePath ? startOpaWithConfigFile(opaConfigFilePath) : startOpaWithLocalInput();
}
/** Stops, then starts OPA again. */
async function restartOpa() {
    await stopOpa();
    await startOpaByType();
}
/** Performs an HTTP call to OPA's /health endpoint, then performs the following actions based on the result:
 * OPA not running -> start OPA
 * OPA returns HTTP code 2xx -> no action
 * OPA returns HTTP code other than 2xx -> restart OPA
 */
async function assertOpaIsRunning() {
    try {
        await axios.get(`${devEnv.localOpaAddress}/health`);
        LOG.debug('OPA is already running healthy.');
    }
    catch (error) {
        try {
            if (error.code === 'ECONNREFUSED') {
                LOG.debug('OPA is not running. Starting OPA.');
                await startOpaByType();
            }
            else {
                LOG.debug('OPA is not running healthy. Restarting OPA.');
                await restartOpa();
            }
        }
        catch (error) {
            LOG.error('Unable to start a healthy OPA instance.');
            LOG.error(error.stdout);
        }
    }
}
/**
 * Sets the path to a configuration file for the next start of OPA.
 * Pass null to clear the configuration file and start OPA on local input files next time.
 *
 * @param {path} configFilePath path to OPA configuration file
 */
function setOpaConfigFile(configFilePath) {
    opaConfigFilePath = configFilePath;
}
module.exports = {
    compileCds,
    copyCustomPolicies,
    cleanDclOutput,
    compileDcl: compileLocalDcl,
    cleanLocalRego,
    writePolicyAssignments,
    assertOpaIsRunning: assertOpaIsRunning,
    startOpa: startOpaByType,
    stopOpa,
    restartOpa,
    setOpaConfigFile
};
//# sourceMappingURL=capAmsFlow.js.map
"use strict";
/* eslint-disable @typescript-eslint/no-var-requires */
const path = require('path');
const fs = require('fs');
const cds = require('@sap/cds');
const { prepareFolders, debouncePromise } = require('../util');
const LOG = cds.log('ams');
const config = require('@sap/ams').cap.config;
const runtimeEnv = require('@sap/ams').cap.env;
const devEnv = require('./capAmsDevEnv');
const capAmsDevEnv = require('./capAmsDevEnv');
const capAmsFlow = require('./capAmsFlow');
const DCL_COMPILATION_DEBOUNCE_PARAMETER = 500;
let AmsInstance; // lazy loaded
let watch; // lazy loaded
let initialized = false;
/** Entry-point for AMS dev plugin. Must only be called once to bootstrap the plugin when the CAP application starts. */
function init() {
    if (initialized) {
        throw new Error('AMS dev plugin has already been initialized.');
    }
    if (runtimeEnv.supportedAuthActive()) {
        LOG.debug('AMS Dev Plugin loaded.');
        initialized = true;
    }
    else {
        LOG.warn('AMS Dev Plugin not loaded because active auth kind is neither \'mocked\' nor \'ias\'.');
        return;
    }
    registerBuildPlugin();
    cds.once('bootstrap', () => {
        if (runtimeEnv.mockedAuthActive()) {
            prepareForMockedAuth();
        }
        if (cds.watched) {
            // manage a local OPA instance with always up-to-date REGO files
            watchDclFolder();
            // shutdown OPA when app shuts down
            cds.once('shutdown', () => {
                LOG.debug('Shutting down OPA.');
                capAmsFlow.stopOpa([]);
            });
            if (config.autoCompile) {
                // copy custom policies to DCL output folder whenever they are changed
                watchCustomDclFolder();
                // compile CDS -> DCL when CAP model is loaded
                cds.on('loaded', model => {
                    if (!model) {
                        return;
                    }
                    LOG.debug('CDS model loaded. Compiling model to base DCL (flag env.requires.auth.ams.autoCompile = true in CAP profile).');
                    compileCdsToDcl(model);
                });
            }
            else {
                capAmsFlow.assertOpaIsRunning();
            }
        }
    });
}
function registerBuildPlugin() {
    cds?.build?.register?.('ams', { impl: path.join(__dirname, 'AmsBuildPlugin.js'), taskDefaults: { src: cds.env.folders.srv }, description: 'Builds AMS DCL policies from CDS model and weaves in custom DCL policies.' });
}
async function compileCdsToDcl(model) {
    await capAmsFlow.cleanDclOutput();
    try {
        await capAmsFlow.compileCds(model);
        LOG.debug('CDS compilation finished.');
    }
    catch (err) {
        LOG.error('Could not compile CDS model to DCL.', err);
        return;
    }
    try {
        capAmsFlow.copyCustomPolicies();
        LOG.debug('Copied custom DCL policies to DCL output folder.');
    }
    catch (e) {
        LOG.error('Could not copy custom DCL policies to DCL output folder.', e);
    }
}
/**
* To support mocked auth, the mocked user objects are decorated at runtime with an app_tid and scim_id based on the CAP user's tenant and id.
* If those attributes are explicitely specified in the configuration, the values from the config have priority over the derived values.
* In addition, a policy assignment file is generated for a local OPA instance that contains user assignments based on assignments mocked via the 'policies' array of the mocked users.
*
* Example:
*
* "users" : {
* 		"user1" : {  				-> copied to user.attr.scim_id
* 			"tenant" : "tenant1",	-> copied to user.attr.app_tid
* 			"policies" : [			-> copied to policy assignments file
* 				"Admin",
* 				"Reader"
*			]
* 		}
* }
*/
function prepareForMockedAuth() {
    const mockedUsers = cds.requires.auth.users || {};
    const policiesByTenantByUser = {};
    for (const [userId, user] of Object.entries(mockedUsers)) {
        if (typeof user !== 'object')
            continue; // skip {* : true} entry
        const scim_id = user.attr?.scim_id || user.id || userId;
        const app_tid = user.attr?.app_tid || user.tenant || '';
        decorateUserWithIasPrinciple(user, app_tid, scim_id);
        // collect user policies
        if (!policiesByTenantByUser[app_tid])
            policiesByTenantByUser[app_tid] = {};
        policiesByTenantByUser[app_tid][scim_id] = Array.isArray(user.policies) ? user.policies : [];
    }
    try {
        capAmsFlow.writePolicyAssignments(policiesByTenantByUser);
    }
    catch (err) {
        LOG.error(`Could not write policy assignments for OPA to ${err.filePath}. Policy assignments from mocked authentication might not work.`);
    }
}
/**
* Makes sure the user object has an 'tokenInfo' property whose payload contains the given values for app_tid and scim_id.
* This is necessary to immitate a user object with an IAS tokenInfo during mocked auth.
* @param {*} user a CAP user object
*/
function decorateUserWithIasPrinciple(user, app_tid, scim_id) {
    user.tokenInfo = { getPayload: () => ({ app_tid, scim_id }) };
}
/* Schedule compilation of DCL to REGO whenever a DCL file is changed. Afterwards make sure that OPA is running. */
async function watchDclFolder() {
    watch ??= require('node-watch');
    const dclFolder = devEnv.getPathToDclOutput();
    await prepareFolders([dclFolder]);
    watch(dclFolder, { recursive: true, filter: /\.dcl$/ }, debouncePromise(dclFileChanged, DCL_COMPILATION_DEBOUNCE_PARAMETER));
}
/* Schedule compilation of DCL to REGO whenever a DCL file is changed. Afterwards make sure that OPA is running. */
async function watchCustomDclFolder() {
    watch ??= require('node-watch');
    const customDclFolder = devEnv.pathToCustomDcl;
    await prepareFolders([customDclFolder]);
    watch(customDclFolder, { recursive: true, filter: /\.dcl$/ }, customDclFileChanged);
}
/** Reaction to DCL file changes. Recompiles DCL to REGO. In Hybrid mode, pushes DCL to AMS Server instead and configures OPA against cloud services. */
async function dclFileChanged(eventType, filename) {
    LOG.debug(`DCL file ${filename} was ${eventType}d. Recompiling DCL to REGO.`);
    if (runtimeEnv.iasAuthActive()) {
        // Hybrid mode => use AMS service instance for OPA
        const iasCredentials = cds.env?.requires?.auth?.credentials;
        if (iasCredentials == null) {
            LOG.warn('IAS auth detected but credentials not found or empty. Cannot run in hybrid mode.');
            return;
        }
        AmsInstance ??= require('@sap/ams').runtime.AmsInstance;
        const amsInstance = new AmsInstance(iasCredentials);
        if (config.autoPushDcl) {
            // Push DCL policies to AMS server
            // Todo: Calculate SHA256 of local policies and push only when it differs from current policies
            // Use new HEAD request to get current SHA256 from server
            await amsInstance.uploadBaseDCL(devEnv.getPathToDclOutput());
        }
        // configure capAmsFlow with OPA config that targets AMS Server
        const opaFolder = devEnv.pathToLocalOpaInput;
        await amsInstance.writeOPAConfig(opaFolder);
        capAmsFlow.setOpaConfigFile(path.join(opaFolder, 'config.yml'));
    }
    else {
        // Local mode => compile REGO files for OPA
        try {
            await capAmsFlow.compileDcl();
        }
        catch (err) {
            LOG.error('DCL could not be compiled.', err);
            return;
        }
    }
    capAmsFlow.assertOpaIsRunning();
}
/** Reaction to custom DCL file changes. Syncs the file change (file create/update/delete) to the DCL output directory under the same relative file path. */
async function customDclFileChanged(eventType, filename) {
    const customDclFolder = devEnv.pathToCustomDcl;
    const relativePath = path.relative(customDclFolder, filename);
    const dclOutputFolder = capAmsDevEnv.getPathToDclOutput();
    const targetPath = path.resolve(dclOutputFolder, relativePath);
    if (eventType === 'update' || eventType === 'create') {
        if (!fs.existsSync(path.dirname(targetPath))) {
            fs.mkdirSync(path.dirname(targetPath), { recursive: true });
        }
        await fs.promises.copyFile(filename, targetPath);
    }
    else if (eventType === 'remove') {
        await fs.promises.rm(targetPath);
    }
}
/** Checks whether the plugin has been initialized. If init was called but the plugin did not run due to the CAP configuration, this will still return false. */
function isInitialized() {
    return initialized;
}
/** Resets the initialized state of the plugin to false. This function must only be used for unit testing. */
function reset() {
    initialized = false;
}
module.exports = { init, isInitialized, reset };
//# sourceMappingURL=amsDevPlugin.js.map
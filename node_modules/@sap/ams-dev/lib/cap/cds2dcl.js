"use strict";
const cds = require("@sap/cds");
/**
 * Regex for validating alias identifiers
 * @type {RegExp}
 */
const REGEX_ALIAS = /^[a-zA-Z_][a-zA-Z_0-9]*$/;
/**
 * Holds keys used in CDS annotations (set on services and entities)
 */
const CDS_ANNOTATION = {
    /**
     * Name of the annotation that holds alias for the exposed entity or service
     */
    ALIAS: "@ams.alias",
    /**
     * Name of the annotation that holds an array of objects where every object exposes (to AMS) a specific field.
     */
    PUBLIC_FIELDS: "@ams.publicFields"
};
/**
 * Holds keys used inside CDS_ANNOTATION.PUBLIC_FIELDS
 */
const CDS_ANNOTATION_FIELD = {
    /**
     * Name of the annotation that holds the alias (in AMS) for the field
     */
    ALIAS: "alias",
    /**
     * Name of the annotation that holds the reference to the target field
     */
    VALUE: "value",
    /**
     * Annotation key that holds DCL-Annotations (please distinguish CDS-annotations and DCL-annotations)
     */
    ANNOTATIONS: "annotations"
};
/**
 * Holds keys used in the _dcl_.cap file.
 */
const MAPPING_FILE_KEYS = {
    NAME: "name",
    ALIAS: "alias",
    RESOURCES: "resources",
    ATTRIBUTES: "attributes",
    ATTRIBUTE_TYPE: "attributeType"
};
/**
 * Mapping for CAP base types to DCL types
 */
const CAP_TO_DCL_TYPES = {
    "cds.UUID": "String",
    "cds.String": "String",
    "cds.Int16": "Number",
    "cds.Int32": "Number",
    "cds.Int64": "Number",
    "cds.Integer": "Number",
    "cds.Integer64": "Number",
    "cds.Decimal": "Number",
    "cds.Double": "Number",
    "cds.Boolean": "Boolean",
};
/**
 * These roles (CAP pseudo roles) will be ignored.
 *
 * @type {string[]}
 */
const CAP_PSEUDO_ROLES = [
    "authenticated-user",
    "system-user",
    "any"
];
/**
 * Base policies will get this actions. Currently always setting all actions.
 *
 * @type {string}
 */
const ACTIONS_FOR_BASE_POLICIES = "*";
/*
 * @param model a CDS model
 * @param verbose
 * @returns {Promise<{schema: string, basePolicies: string, _dcl_cap: {resources: *[]}, csn: *}>}
 */
async function convert(model, verbose) {
    const csn = cds.linked(model);
    // -------------------- BEGIN encapsulated functions
    let debug;
    // Define debug function. If verbose option enabled then it will write actual logs, otherwise it will do nothing.
    if (verbose) {
        debug = function (...args) {
            try {
                // Try fancy output
                const reset = "\x1b[0m";
                // let highlight = "\x1b[1m\x1b[4m\x1b[33m"
                const highlight = "\x1b[1m\x1b[33m";
                const newArgs = [];
                for (const arg of args) {
                    if (typeof arg === "string") {
                        const pp = ("" + arg).split("\"");
                        let newS = pp[0];
                        for (let i = 1; i < pp.length; i++) {
                            const ppElement = pp[i];
                            if (i % 2 === 0) {
                                newS += reset;
                            }
                            else {
                                newS += highlight;
                            }
                            newS += ppElement;
                        }
                        newS += reset;
                        newArgs.push(newS);
                    }
                    else {
                        newArgs.push(arg);
                    }
                }
                console.log.apply(console, ["cds2dcl:", ...newArgs]);
            }
            catch (e) {
                console.log.apply(console, ["cds2dcl:", ...args]);
            }
            // console.log.apply(console, ["cds2dcl:", ...args])
        };
    }
    else {
        debug = function () { };
    }
    /**
     * Function for writing warning logs. Calls debug function and then prints warn level logs directly to console.
     * @param args
     */
    const warn = function (...args) {
        debug(...args);
        console.warn.apply(console, [...args]);
    };
    /**
     * Function for throwing an error. Calls debug function with the error and then throws an actual Error.
     * @param e
     */
    const throwError = function (e) {
        debug(e);
        throw new Error(e);
    };
    /**
     * Recursive function that returns root base type that the specified type inherits from. If the root type is not
     * a base type (e.g. struct) or the type name is not found then returns null.
     * @param csn Parsed CAP model.
     * @param typeName Name of the type which base type is needed.
     * @param path Optional. Not to be used from outside (it is used for recursive calls). It is
     * used for debug output and for detection of endless recursion.
     * @param processedTypes Optional. Not to be used from outside (it is used for recursive calls). Array of
     * already processed types.
     * @returns {null|*}
     */
    function getBaseType(csn, typeName, path, processedTypes) {
        // TODO path can be eliminated by using just processedTypes
        // TODO Edge cases were not really tested because CAP seems to prevent such cases any way. Kept them just in case it goes wrong
        // Fill in optional params.
        path = path || "";
        path += " -> " + typeName;
        processedTypes = processedTypes || [];
        // Check for circular reference
        if (processedTypes.indexOf(typeName) >= 0) {
            warn(`W018: circular reference found while resolve custom type ${processedTypes[0]}, resolved path: ${path}`);
            return null;
        }
        processedTypes.push(typeName);
        // Double check for endless recursion (not deeper than 100 references and path length  smaller than 1000).
        if (processedTypes.length > 100 || path.length > 1000) {
            // Prevent endless recursion just in case it goes wrong
            warn(`W017: cannot resolve type ${typeName}, resolved path too long: ${path}`);
            return null;
        }
        // Check if we are already at the root (base types start with "cds.") and return the type name.
        if (typeName.indexOf("cds.") === 0) {
            return typeName;
        }
        else {
            // Otherwise look for type definition
            const definition = csn.definitions[typeName];
            // If it's found
            if (definition && definition.kind === "type") {
                // Check if it inherits from other type
                if (definition.type) {
                    // ... and resolve the parent type
                    return getBaseType(csn, definition.type, path, processedTypes);
                }
                else {
                    // ... otherwise assume it's not inherited from a type but from a struct and thus
                    // cannot be resolved to a base type.
                    warn(`W014: type ${typeName} is not a simple type (${path})`);
                    return null;
                }
            }
            else {
                // Otherwise if it is not found warn and return null
                warn(`W016: cannot resolve type ${typeName} (${path})`);
                return null;
            }
        }
    }
    /**
     * Validates alias name used in AMS annotations. Throws error if it's not a valid one.
     * @param alias
     */
    function validateAliasName(alias) {
        if (!REGEX_ALIAS.test(alias)) {
            throwError(`E004: an invalid alias "${alias}" was used`);
        }
    }
    // function createMapRecordForElement(capName, dclName, attrType) {
    //     let res = {};
    //
    //     res[MAPPING_FILE_KEYS.NAME] = capName;
    //     res[MAPPING_FILE_KEYS.ALIAS] = dclName;
    //     res[MAPPING_FILE_KEYS.ATTRIBUTE_TYPE] = attrType;
    //
    //     return res;
    // }
    /**
     * Generates mapping record for specified service (mapping is later stored into the _dcl_.cap file).
     * @param capName
     * @param dclName
     * @returns {{}}
     */
    function createMapRecordForService(capName, dclName) {
        const res = {};
        res[MAPPING_FILE_KEYS.NAME] = capName;
        res[MAPPING_FILE_KEYS.ALIAS] = dclName;
        res[MAPPING_FILE_KEYS.RESOURCES] = [];
        return res;
    }
    /**
     * Generates mapping record for specified entity (mapping is later stored into the  _dcl_.cap file).
     * @param capName
     * @param dclName
     * @returns {{}}
     */
    function createMapRecordForEntity(capName, dclName) {
        const res = {};
        res[MAPPING_FILE_KEYS.NAME] = capName;
        res[MAPPING_FILE_KEYS.ALIAS] = dclName;
        //res[MAPPING_FILE_KEYS.RESOURCES] = [];
        res[MAPPING_FILE_KEYS.ATTRIBUTES] = [];
        return res;
    }
    /**
     * Returns array of all roles defined on the specified element (it can be an entity or a service).
     *
     * Looks into @requires and @restrict annotations to gather roles.
     *
     * @param element
     * @returns {*[]}
     */
    const extractRoleNamesToArray = function (element) {
        const temp = [];
        if (element["@restrict"]) {
            for (const restrict of [].concat(element["@restrict"])) {
                if (restrict.to) {
                    temp.push(...[].concat(restrict.to /*|| "AnyAnyAny"*/));
                }
                else {
                    const l = element.name + " -> " + JSON.stringify(restrict).substr(0, 20) + "...";
                    warn(`W012: Ignored @restrict(${l}) because it doesn't have 'to' field.`);
                }
            }
        }
        if (element["@requires"]) {
            for (const requires of [].concat(element["@requires"])) {
                temp.push(...[].concat(requires));
            }
        }
        const result = [];
        for (const tempElement of temp) {
            if (CAP_PSEUDO_ROLES.indexOf(tempElement) >= 0) {
                // Skip
            }
            else {
                if (result.indexOf(tempElement) < 0) {
                    result.push(tempElement);
                }
            }
        }
        return result;
    };
    /**
     * Extracts role names and saves them into the dictionary. Will skip roles that were collected before.
     * @param rolesArray Roles arrays from CAP model
     * @param rolesDict Dictionary used to cache all found roles.
     */
    const extractRoleNamesToDict = function (rolesArray, rolesDict) {
        for (const roleName of rolesArray) {
            debug(`     Role "${roleName}"`);
            if (CAP_PSEUDO_ROLES.indexOf(roleName) >= 0) {
                debug("      Skipping.\"");
                continue;
            }
            if (!rolesDict[roleName]) {
                rolesDict[roleName] = [`GRANT "${roleName}" ON $SCOPES;`];
                debug(`      Collected role: "${roleName}"`);
            }
            else {
                debug("      Skipped role because it was already collected.");
            }
        }
    };
    /**
     * Tells if a service has entities with AMS-annotations
     * @param service
     * @returns {boolean}
     */
    const hasAnnotatedEntities = function (service) {
        const annotatedServices = [...csn.each(x => x.kind === "entity" && x._service == service && (x[CDS_ANNOTATION.ALIAS] || x[CDS_ANNOTATION.PUBLIC_FIELDS]))];
        return annotatedServices.length > 0;
    };
    // -------------------- END encapsulated functions
    // -------------------- BEGIN with actual logic
    // 1. Use CDS module to read service models
    // 2. Go through models and look for abstractions having AMS annotations
    // 3. Build DCL-schema for every abstraction that has to be exposed to AMS; collect policy rules for them
    // 4. Go through models and collect remaining roles from @requires and from @restrict
    // 5. Write filter policies out
    // Prepare object for building the _dcl_.cap file
    const _dcl_cap = {
        "resources": []
    };
    // 2. + 3. Go through the model tree, look for things with AMS annotations and
    //     A. put them into DCL schema
    //     B. look for associated roles, make policies for them and include rules for public fields
    let schemaContent = "";
    let filterPolicies = ""; // new one
    const roleDict = {}; // new one
    const serviceAliases = {};
    debug("Go through services...");
    for (const service of csn.services) {
        // Process a service only if it has annotations itself or its entities have them otherwise ignore it
        if (service[CDS_ANNOTATION.ALIAS] || hasAnnotatedEntities(service)) {
            const serviceAlias = service[CDS_ANNOTATION.ALIAS] || service.name;
            debug(` Found annotated service "${service.name}", effective alias: "${serviceAlias}"`);
            if (serviceAliases[serviceAlias]) {
                throwError(`E001: Service "${service.name}" has an alias "${serviceAlias}" that is already being used another service.`);
            }
            else {
                serviceAliases[serviceAlias] = true;
            }
            validateAliasName(serviceAlias);
            const mapService = createMapRecordForService([service.name], [serviceAlias]);
            _dcl_cap.resources.push(mapService);
            let serviceContent = "";
            const entityAliases = {};
            debug("  Going through entities of the service:");
            for (const entity of csn.entities(service.name)) {
                let entityAlias = entity[CDS_ANNOTATION.ALIAS];
                // In case alias not set - check if entity has AMS annotations and use entity name as alias
                if (!entityAlias) {
                    if (entity[CDS_ANNOTATION.PUBLIC_FIELDS] && entity[CDS_ANNOTATION.PUBLIC_FIELDS].length > 0) {
                        entityAlias = entity.name.split(".").pop();
                    }
                }
                // Process entity only if it has AMS-annotations (alias was set or some entries have AMS-annotations
                if (entityAlias) {
                    debug(`   Found annotated entity "${entity.name}", effective alias: "${entityAlias}"`);
                    if (entityAliases[entityAlias]) {
                        throwError(`E002: Entity ${entity.name} of the service ${service.name} has an alias "${entityAlias} that is already being used by another entity.`);
                    }
                    else {
                        entityAliases[entityAlias] = true;
                    }
                    validateAliasName(entityAlias);
                    const mapEntity = createMapRecordForEntity(entity.name.split("."), [serviceAlias, entityAlias]);
                    mapService.resources.push(mapEntity);
                    let entityContent = "";
                    let whereClause = "";
                    const uniqueAliasMap = {};
                    if (entity[CDS_ANNOTATION.PUBLIC_FIELDS] && entity[CDS_ANNOTATION.PUBLIC_FIELDS].length > 0) {
                        debug("    Going through public fields:");
                        for (const publicField of entity[CDS_ANNOTATION.PUBLIC_FIELDS]) {
                            let elementName, element, elementAlias, targetElementPath, elementFullName;
                            if (!publicField[CDS_ANNOTATION_FIELD.VALUE]) {
                                warn(`W011: Annotation lists a public field but doesn't have '${CDS_ANNOTATION_FIELD.VALUE}' field`);
                                continue;
                            }
                            else if (typeof publicField[CDS_ANNOTATION_FIELD.VALUE] === "string") {
                                debug(`     Public field with an element name found: "${publicField[CDS_ANNOTATION_FIELD.VALUE]}"`);
                                elementName = publicField[CDS_ANNOTATION_FIELD.VALUE];
                                elementFullName = elementName;
                                element = entity.elements[elementName];
                                if (!element) {
                                    warn(`W009: Entity "${entity.name}"  doesn't have an element name "${elementName}" as specified in the AMS annotation. `);
                                    continue;
                                }
                                elementAlias = publicField[CDS_ANNOTATION_FIELD.ALIAS] || element.name;
                                targetElementPath = [elementName];
                            }
                            else {
                                elementFullName = publicField[CDS_ANNOTATION_FIELD.VALUE]["="];
                                debug(`     Public field with an element reference found: "${elementFullName}"`);
                                targetElementPath = elementFullName.split(".");
                                if (targetElementPath.length == 1) {
                                    debug("      It's a simple reference");
                                    element = entity.elements[targetElementPath[0]];
                                }
                                else if (targetElementPath.length >= 2) {
                                    debug("      It's a nested reference");
                                    try {
                                        if (entity.elements[targetElementPath[0]]) {
                                            let curElement = entity.elements[targetElementPath[0]];
                                            // Careful! For-loop starts with 1
                                            // It walks over path and moves curElement along it by resolving every part of the path
                                            for (let i = 1; i < targetElementPath.length; i++) {
                                                const nextElementName = targetElementPath[i];
                                                if (curElement._target) {
                                                    curElement = curElement._target.elements[nextElementName];
                                                }
                                                else {
                                                    curElement = csn.definitions[curElement.type].elements[nextElementName];
                                                }
                                            }
                                            element = curElement;
                                        }
                                    }
                                    catch (e) {
                                        // throwError("E015: Cannot process reference: " + elementFullName + " Error: " + e);
                                        warn("W015: Cannot process reference: " + elementFullName + " Error: " + e);
                                    }
                                }
                                else {
                                    throwError("E006: Not supported reference is empty: " + elementFullName);
                                }
                                if (!element) {
                                    warn(`W007: Entity "${entity.name}"  doesn't have an element name "${elementFullName}" as specified in the AMS annotation. `);
                                    continue;
                                }
                                elementAlias = publicField[CDS_ANNOTATION_FIELD.ALIAS] || targetElementPath.join("_");
                                elementName = element.name;
                            }
                            // Handle DCL annotations
                            let dclAnnotations = "";
                            if (publicField[CDS_ANNOTATION_FIELD.ANNOTATIONS]) {
                                for (const ann in publicField[CDS_ANNOTATION_FIELD.ANNOTATIONS]) {
                                    // TODO Most probably additional escaping is necessary - check DCL syntax!!!
                                    let serializedValue = JSON.stringify(publicField[CDS_ANNOTATION_FIELD.ANNOTATIONS][ann]).split("\"").join("'");
                                    serializedValue = "";
                                    if (typeof publicField[CDS_ANNOTATION_FIELD.ANNOTATIONS][ann] === "string") {
                                        serializedValue = `'${publicField[CDS_ANNOTATION_FIELD.ANNOTATIONS][ann]}'`;
                                    }
                                    else {
                                        for (const dclAnnotationElement in publicField[CDS_ANNOTATION_FIELD.ANNOTATIONS][ann]) {
                                            if (serializedValue.length > 0) {
                                                serializedValue += ", ";
                                            }
                                            serializedValue += `${dclAnnotationElement}: '${publicField[CDS_ANNOTATION_FIELD.ANNOTATIONS][ann][dclAnnotationElement]}'`;
                                        }
                                        serializedValue = "{" + serializedValue + "}";
                                    }
                                    dclAnnotations += `            @${ann}: ${serializedValue}\n`;
                                }
                            }
                            // TODO: check if this is always true
                            if (elementAlias) {
                                debug(`      Effective alias of the element is "${elementAlias}"`);
                                if (uniqueAliasMap[elementAlias]) {
                                    throwError(`E003: Element "${elementName}" of the entity "${entity.name}" has an alias "${elementAlias}" which is already used by another element.`);
                                }
                                else {
                                    uniqueAliasMap[elementAlias] = true;
                                }
                                validateAliasName(elementAlias);
                                debug(`      CAP-type of the element is "${element.type}". Going to try to map it to a DCL type.`);
                                let valType = CAP_TO_DCL_TYPES[element.type];
                                if (valType) {
                                    debug(`      DCL-type of the element is "${valType}" (using direct type mapping)`);
                                }
                                if (!valType &&
                                    csn.definitions[element.type] &&
                                    csn.definitions[element.type].kind === "type") {
                                    const baseType = getBaseType(csn, element.type);
                                    // Old simpler variant that checks only one level of inheritance:
                                    // let typeDefinition = csn.definitions[element.type];
                                    // let baseType = typeDefinition.type;
                                    if (baseType) {
                                        debug(`      Element uses a custom type "${element.type}" which inherits from a simple type "${baseType}"`);
                                        valType = CAP_TO_DCL_TYPES[baseType];
                                        debug(`      DCL-type of the element is "${valType}" (taken from the referenced type "${element.type}" which itself resolves to type "${baseType}")`);
                                    }
                                }
                                if (!valType) {
                                    warn(`W005: an invalid type found: "${element.type}". It cannot be mapped to a DCL-type. Element name: "${entity.name}.${element.name}"`);
                                }
                                else {
                                    if (entityContent.length > 0) {
                                        entityContent += ",\n";
                                    }
                                    entityContent += "\n";
                                    entityContent += `            // ${elementFullName} : ${element.type}\n`;
                                    entityContent += dclAnnotations;
                                    entityContent += `            ${elementAlias} : ${valType}`;
                                    debug(`      Adding schema entry "${elementAlias} : ${valType}"`);
                                    const elementMapEntry = {};
                                    elementMapEntry[MAPPING_FILE_KEYS.NAME] = entity.name.split(".").concat(targetElementPath);
                                    elementMapEntry[MAPPING_FILE_KEYS.ALIAS] = [serviceAlias, entityAlias, elementAlias];
                                    elementMapEntry[MAPPING_FILE_KEYS.ATTRIBUTE_TYPE] = valType;
                                    mapEntity[MAPPING_FILE_KEYS.ATTRIBUTES].push(elementMapEntry);
                                    if (whereClause.length > 0) {
                                        whereClause += "\n           AND ";
                                    }
                                    whereClause += `${serviceAlias}.${entityAlias}.${elementAlias} IS NOT RESTRICTED`;
                                }
                                // Match types! Might be complex types?
                            }
                        }
                    }
                    else {
                        warn(`W010: annotated entity "${entity.name}" doesn't list any public fields!`);
                    }
                    if (serviceContent.length > 0) {
                        serviceContent += ",\n";
                    }
                    debug(`    Completed schema entry "${entityAlias}"`);
                    serviceContent += `\n        // ${entity.name}`;
                    serviceContent += `\n        ${entityAlias} : {`;
                    serviceContent += "\n";
                    serviceContent += entityContent;
                    serviceContent += "\n        }";
                    const events = ACTIONS_FOR_BASE_POLICIES;
                    whereClause = whereClause.length > 0 ? `\n         WHERE ${whereClause}` : "";
                    const grantForEntity = `GRANT ${events} ON "${serviceAlias}.${entityAlias}"${whereClause};`;
                    // Filter policies
                    const rolesOnEntity = extractRoleNamesToArray(entity);
                    const rolesOnService = extractRoleNamesToArray(service);
                    debug(`    Found these roles: service roles: ["${rolesOnService}"], entity roles: ["${rolesOnEntity}"].`);
                    let allRoles = [...rolesOnEntity, ...rolesOnService];
                    // warn(allRoles)
                    allRoles = allRoles.filter((value, index, self) => self.indexOf(value) === index);
                    debug(`      Policy-rule will be added to these roles: ["${allRoles}"]`);
                    // warn(allRoles)
                    if (allRoles.length > 0) {
                        for (const roleE of allRoles) {
                            roleDict[roleE] = roleDict[roleE] || [`GRANT "${roleE}" ON $SCOPES;`];
                            roleDict[roleE].push(grantForEntity);
                        }
                    }
                    // if (rolesOnEntity.length > 0) {
                    //     for (const roleE of rolesOnEntity) {
                    //
                    //         roleDict[roleE] = roleDict[roleE] || [`GRANT ${roleE} ON $SCOPES;`];
                    //         roleDict[roleE].push(grantForEntity);
                    //     }
                    // }
                    // if (rolesOnService.length > 0) {
                    //     for (const roleS of rolesOnService) {
                    //
                    //         roleDict[roleS] = roleDict[roleS] || [`GRANT ${roleS} ON $SCOPES;`];
                    //         roleDict[roleS].push(grantForEntity);
                    //     }
                    // }
                }
                else {
                    debug(`   Skipping entity "${entity.name}" - no AMS-annotations found`);
                }
            }
            if (schemaContent.length > 0) {
                schemaContent += ",\n";
            }
            schemaContent += `\n    // ${service.name}`;
            schemaContent += `\n    ${(serviceAlias || service.name)} : {`;
            schemaContent += `\n${serviceContent}`;
            schemaContent += "\n    }";
            if (serviceContent.length === 0) {
                warn(`W009: service "${service.name}" has AMS-annotation but doesn't include any entities that have AMS-annotation`);
            }
        }
        else {
            debug(`Ignoring service ${service.name}`);
        }
    }
    debug("Finished going through services.");
    const schema = `SCHEMA {\n${schemaContent}\n}`;
    // 4.  Go through all @requires and @restrict annotations to find all remaining roles - they
    // will be used for policies without public fields
    debug("Looking for roles in @requires and @restrict annotations everywhere.");
    for (const d of csn.each(x => x["@requires"])) {
        debug(` Entity "${d.name}": found @requires annotation "${d["@requires"]}"`);
        extractRoleNamesToDict([].concat(d["@requires"]), roleDict);
    }
    for (const d of csn.each(x => x["@restrict"])) {
        debug(` Entity "${d.name}": found @restrict annotation"`);
        for (const restrictObj of [].concat(d["@restrict"])) {
            if (restrictObj.to) {
                debug(`  Contains roles "${restrictObj.to}"`);
                extractRoleNamesToDict([].concat(restrictObj.to), roleDict);
            }
        }
    }
    debug("Finished collecting roles.");
    // 5 Write filter policies out
    for (const role in roleDict) {
        filterPolicies += `POLICY "${role}" {\n`;
        for (const rule of roleDict[role]) {
            filterPolicies += `    ${rule}\n`;
        }
        filterPolicies += "}\n\n";
    }
    debug("All done.");
    return { csn: csn, schema, _dcl_cap, scopePolicies: "", basePolicies: filterPolicies };
}
module.exports = {
    /**
     * Generates DCL artifacts for the specified CDS model.
     *
     * @param model a CDS model
     * @param verbose If true will output logs.
     * @returns {Promise<{schema: string, basePolicies: string, _dcl_cap: *, csn: *}>}
     */
    convert,
    /**
     * Gets a JSON schema for _dcl_.cap file.
     * @returns Object
     */
    getDclCapSchema: function () {
        return require("amscap.schema.json");
    }
};
//# sourceMappingURL=cds2dcl.js.map
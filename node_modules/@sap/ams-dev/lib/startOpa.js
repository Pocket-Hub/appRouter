"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getOpaCommandlineString = exports.startOpaByConfig = exports.startOpa = void 0;
const child_process_1 = require("child_process");
const yargs_1 = __importDefault(require("yargs"));
const util = __importStar(require("./util"));
let logger = util.getLogger('error');
function validateOpaConfig(options) {
    options = Object.assign({}, options);
    if (!options.address) {
        options.address = '127.0.0.1';
    }
    if (!options.port) {
        options.port = 8181;
    }
    if (!options.logLevel) {
        options.logLevel = 'error';
    }
    if (!options.name) {
        options.name = '';
    }
    if (options.daemonize !== false) {
        options.daemonize = true;
    }
    if (options.watch !== false) {
        options.watch = true;
    }
    if (!options.configFile) {
        if (options.userPath == undefined || options.regoPath == undefined) {
            throw new Error(`Invalid Parameter for userPath(${options.userPath}), regoPath(${options.regoPath}) or configFile(${options.configFile})`);
        }
    }
    return options;
}
function getOpaCommandlineString(options) {
    const args = getCommandArguments(validateOpaConfig(options));
    return args.join(' ');
}
exports.getOpaCommandlineString = getOpaCommandlineString;
function getCommandArguments(options) {
    const all = [
        '--server',
        '--log-level',
        options.logLevel,
        '--addr',
        `${options.address}:${options.port}`,
        '--disable-telemetry'
    ];
    if (options.configFile) {
        return [
            'run',
            '--config-file',
            options.configFile
        ].concat(all);
    }
    else {
        if (options.watch) {
            all.push('--watch');
        }
        const args = ['run'];
        util.pushIfNotEmpty(args, options.userPath);
        args.push('--server');
        util.pushIfNotEmpty(args, options.regoPath);
        args.push('--set', 'plugins.dcl=true', '--set', 'status.plugin=dcl');
        return args.concat(all);
    }
}
async function startOpaByConfig(options) {
    options = validateOpaConfig(options);
    const opaPath = util.getOpaPath();
    const cmdArgs = getCommandArguments(options);
    let opaProcess;
    if (options.daemonize === false) {
        logger.info(`starting opa in foreground. port: ${options.port} name: ${options.name}`);
        opaProcess = (0, child_process_1.spawn)(opaPath, cmdArgs, { detached: false });
        opaProcess.stdout.setEncoding('utf8');
        opaProcess.stdout.on('data', function (data) {
            logger.info('stdout: ' + data);
        });
        opaProcess.stderr.setEncoding('utf8');
        opaProcess.stderr.on('data', function (data) {
            logger.error('stderr: ' + data);
        });
    }
    else {
        util.checkValidProcessName(options.name || '');
        // check if it starts without error
        if (!await wouldStartWithoutError(opaPath, cmdArgs, 900))
            throw (`Opa can not start without error. Check if port ${options.port} is already in use.`);
        opaProcess = (0, child_process_1.spawn)(opaPath, cmdArgs, { detached: true, stdio: ['ignore', 'ignore', 'ignore'] });
        opaProcess.unref();
        writePid(opaProcess.pid, options.port, options.name || '');
        logger.info(`started opa in background. pid: ${opaProcess.pid} port: ${options.port} name: ${options.name}`);
    }
    return opaProcess;
}
exports.startOpaByConfig = startOpaByConfig;
async function startOpa(args) {
    const options = (0, yargs_1.default)(args)
        .options({
        r: { alias: 'rego', describe: 'path to rego policies folder', type: 'string', demandOption: false, default: '' },
        u: { alias: 'user2policy', describe: 'optional path to a json file which maps policies to users', type: 'string', demandOption: false, default: '' },
        p: { alias: 'port', describe: 'port of the opa server', type: 'string', demandOption: false, default: '8181' },
        d: { alias: 'daemonize', describe: 'starts the opa as detached background process', type: 'boolean', demandOption: false, default: true },
        n: { alias: 'name', describe: 'gives the opa process a name which can be used to stop it', type: 'string', demandOption: false, default: '' },
        l: { type: 'string', alias: 'log-level', describe: 'log level', default: 'error', demandOption: false, choices: ['debug', 'info', 'warn', 'error', 'silent'] },
        w: { alias: 'watch', describe: 'starts OPA in watch mode', type: 'boolean', default: true, demandOption: false },
        c: { alias: 'config-file', describe: 'start opa with a config file', type: 'string', demandOption: false },
    })
        .example('start-opa -r rego/ -u user2policies.json', 'start opa with rego files in rego/ and user2policies.json mapping')
        .usage('Usage: start-opa -r [REGO_PATH] -u [USER_TO_POLICY_FILE] -p [PORT]')
        .parseSync();
    logger = util.getLogger(options.l);
    const config = {
        regoPath: options.r,
        userPath: options.u,
        configFile: options.c,
        port: parseInt(options.p),
        daemonize: options.d,
        name: options.n,
        address: '127.0.0.1',
        watch: options.w,
        logLevel: 'error'
    };
    return startOpaByConfig(config);
}
exports.startOpa = startOpa;
function writePid(pid, port, name) {
    const opaPids = util.opaProcesses();
    opaPids.push({
        'pid': pid,
        'port': port,
        'name': name,
    });
    util.persistProcesses(opaPids);
}
function wouldStartWithoutError(opaPath, cmdArgs, timeoutMs) {
    const opaProcessTest = (0, child_process_1.spawn)(opaPath, cmdArgs, { detached: false });
    return Promise.race([
        new Promise((resolve) => {
            let result = '';
            opaProcessTest.stdout.on('data', function (data) {
                result += data.toString();
            });
            opaProcessTest.on('close', function (code) {
                if (code != 0 || result) {
                    logger.error(`exit code: ${code}`);
                    logger.error(result);
                    resolve(false);
                }
            });
        }),
        new Promise((resolve) => setTimeout(() => {
            opaProcessTest.removeAllListeners();
            opaProcessTest.kill();
            resolve(true);
        }, timeoutMs)),
    ]);
}
//# sourceMappingURL=startOpa.js.map
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.prepareFolders = exports.debouncePromise = exports.getOpaPath = exports.pushIfNotEmpty = exports.checkValidProcessName = exports.getLogger = exports.persistProcesses = exports.opaProcesses = void 0;
const fs_1 = __importDefault(require("fs"));
const path = __importStar(require("path"));
const os = __importStar(require("os"));
const OPA_PID_FILENAME = 'opa-pid.json';
const AMS_CONFIG_FILENAME = 'config.json';
const AMS_DEV_CONFIG_DIR = path.join(os.homedir(), '.ams');
const DEFAULT_OPA_PID_PATH = path.join(__dirname, '..', 'resources', 'status', OPA_PID_FILENAME);
/**
 * return the in background running opa instances
 * @returns json array in form [{"pid": 1234, "port": 8181, "name": "test", }]
 */
function opaProcesses() {
    const pidPath = getOpaPidPath();
    const pidDir = path.dirname(pidPath);
    if (!fs_1.default.existsSync(pidDir)) {
        fs_1.default.mkdirSync(pidDir, { recursive: true });
    }
    if (!fs_1.default.existsSync(pidPath)) {
        fs_1.default.writeFileSync(pidPath, '[]');
    }
    return JSON.parse(fs_1.default.readFileSync(pidPath, 'utf-8'));
}
exports.opaProcesses = opaProcesses;
function persistProcesses(prcs) {
    const path = getOpaPidPath();
    fs_1.default.writeFileSync(path, JSON.stringify(prcs));
}
exports.persistProcesses = persistProcesses;
var LogLevel;
(function (LogLevel) {
    LogLevel[LogLevel["Debug"] = 0] = "Debug";
    LogLevel[LogLevel["Info"] = 1] = "Info";
    LogLevel[LogLevel["Warn"] = 2] = "Warn";
    LogLevel[LogLevel["Error"] = 3] = "Error";
    LogLevel[LogLevel["Silent"] = 4] = "Silent";
})(LogLevel || (LogLevel = {}));
function parseLogLevel(l) {
    switch (l) {
        case 'debug':
            return LogLevel.Debug;
        case 'info':
            return LogLevel.Info;
        case 'warn':
            return LogLevel.Warn;
        case 'error':
            return LogLevel.Error;
        case 'silent':
            return LogLevel.Silent;
        default:
            throw ('unsupported log level');
    }
}
class Logger {
    constructor(lvl) {
        this.logLevel = parseLogLevel(lvl);
        if (getConfig().log) {
            this.logLevel = parseLogLevel(getConfig().log);
        }
    }
    logLevel;
    debug(msg) {
        if (this.logLevel <= LogLevel.Debug)
            console.log(msg);
    }
    info(msg) {
        if (this.logLevel <= LogLevel.Info)
            console.log(msg);
    }
    warn(msg) {
        if (this.logLevel <= LogLevel.Warn)
            console.log(msg);
    }
    error(msg) {
        if (this.logLevel <= LogLevel.Error)
            console.log(msg);
    }
}
function getLogger(configLevel) {
    return new Logger(configLevel);
}
exports.getLogger = getLogger;
function checkValidProcessName(name) {
    if (name.includes(',')) {
        throw ('not allowed character \',\' in process name');
    }
}
exports.checkValidProcessName = checkValidProcessName;
function pushIfNotEmpty(arr, arg) {
    if (arg)
        arr.push(arg);
}
exports.pushIfNotEmpty = pushIfNotEmpty;
function getOpaPath() {
    const opaPath = path.join(__dirname, '..', 'resources', 'opa');
    switch (process.platform) {
        case 'darwin': {
            return path.join(opaPath, 'darwin', 'opa');
        }
        case 'win32': {
            return path.join(opaPath, 'windows', 'opa.exe');
        }
        case 'linux': {
            return path.join(opaPath, 'linux', 'opa');
        }
        default: {
            throw new Error(`unsupported operating system: ${process.platform}`);
        }
    }
}
exports.getOpaPath = getOpaPath;
// eslint-disable-next-line @typescript-eslint/ban-types
function debouncePromise(fn, ms = 0) {
    let timeoutId;
    const pending = [];
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    return (...args) => new Promise((res, rej) => {
        clearTimeout(timeoutId);
        timeoutId = setTimeout(() => {
            const currentPending = [...pending];
            pending.length = 0;
            Promise.resolve(fn.call(null, ...args)).then(data => {
                currentPending.forEach(({ resolve }) => resolve(data));
            }, error => {
                currentPending.forEach(({ reject }) => reject(error));
            });
        }, ms);
        pending.push({ resolve: res, reject: rej });
    });
}
exports.debouncePromise = debouncePromise;
/**
* Creates the given folders if they do not exist.
* @param {Array<string>} folders array of folder paths
*/
function prepareFolders(folders) {
    return Promise.all(folders.map(f => {
        if (!fs_1.default.existsSync(f)) {
            return fs_1.default.mkdirSync(f, { recursive: true });
        }
    }));
}
exports.prepareFolders = prepareFolders;
/**
 * either returns default path or if $HOME/.ams there
 * @returns path to opa pid file which stores background processes
 */
function getOpaPidPath() {
    if (fs_1.default.existsSync(AMS_DEV_CONFIG_DIR)) {
        const newPidPath = path.join(AMS_DEV_CONFIG_DIR, OPA_PID_FILENAME);
        return newPidPath;
    }
    return DEFAULT_OPA_PID_PATH;
}
function getConfig() {
    const configPath = path.join(AMS_DEV_CONFIG_DIR, AMS_CONFIG_FILENAME);
    if (fs_1.default.existsSync(configPath)) {
        return JSON.parse(fs_1.default.readFileSync(configPath, 'utf-8'));
    }
    return {};
}
//# sourceMappingURL=util.js.map